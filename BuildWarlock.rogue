# To run this build file, install Rogue from github.com/brombres/Rogue then cd
# to this folder and type "rogo" at the command line, or "rogo help" for a list
# of supported commands.

$define SDL_BRANCH "preview-3.1.6"
#$define SDL_BRANCH "release-2.30.x"

$requireRogue "2.34.3"

uses Utility/GitRepo
uses Utility/VersionNumber

#$ LINK_LIBS            = true
   # Link the following in when compiling this Build.rogue

#$ LIBRARIES(macOS)   = libjpeg
#$ LIBRARIES(macOS)   = libpng
#$ LIBRARIES(macOS)   = zlib(flags:-lz)
#$ LIBRARIES(Linux)   = libjpeg(install:libjpeg-dev)
#$ LIBRARIES(Linux)   = libpng(install:libpng-dev)
#$ LIBRARIES(Windows) = brombres/windowsmedialibs
#$ CC_LINK(macOS)     = -I /System/Libraries/Frameworks -framework Foundation -framework AppKit
#$ CC_LINK(Windows)   = /link /LTCG

uses Graphics
uses Graphics/BitmapIO

augment Build
  PROPERTIES
    shader_name_pairs =
    @[
      ["-vs","-fs"],
      ["vs-","fs-"],
      ["_vs","_fs"],
      ["vs_","fs_"],
      ["-vert","-frag"],
      ["vert-","frag-"],
      ["_vert","_frag"],
      ["vert_","frag_"]
    ]
endAugment

routine rogo_default
  rogo_deps
  rogo_compile_assets
  rogo_help
endRoutine

routine rogo_macos_open
  open_xcode( "Platforms/macOS" )
endRoutine

routine rogo_clean
  File("Build").delete
endRoutine

routine rogo_compile_assets
  compile_assets( System.os )
endRoutine

routine rogo_shaders( platform=null:String )
  if (not String.exists(platform)) platform = System.os

  local dest = File( "Build/$/Assets/Shaders"(platform) )
  ensure_folder( dest )

  local shaderc : String
  local platform_flags : String
  which (platform)
    case "macOS"
      shaderc = "Libraries/bgfx/.build/osx-arm64/bin/shadercRelease"
      platform_flags = "--platform osx --profile metal"
    others
      println "[SHADERS] No shader build process is defined for platform '$'."(platform)
      return
  endWhich

  local vs_cmd = "$ --type vertex"(shaderc).appending( platform_flags )
  local fs_cmd = "$ --type fragment"(shaderc).appending( platform_flags )

  local files = Files( "Libraries/Warlock/Libraries/Shaders/*" )

  local pairs = organize_shader_pairs( files->String[] )

  local header_shown = false
  forEach (pair in pairs)
    local src_vs = File( pair//vs )
    local src_fs = File( pair//fs )
    local dest_vs = (dest / src_vs.filename).with_extension( ".bin" )
    local dest_fs = (dest / src_fs.filename).with_extension( ".bin" )

    if (src_vs.is_newer_than(dest_vs))
      header_shown = banner( "Compiling shaders", &skip=header_shown )
      execute vs_cmd.appending( "-f $ -o $"(src_vs.esc,dest_vs.esc) )
    endIf

    if (src_fs.is_newer_than(dest_fs))
      header_shown = banner( "Compiling shaders", &skip=header_shown )
      execute fs_cmd.appending( "-f $ -o $"(src_fs.esc,dest_fs.esc) )
    endIf
  endForEach
endRoutine

routine organize_shader_pairs( filepaths:String[] )->Variant
  local result = @[]

  while (filepaths.count)
    local vs = find_shader( filepaths, 0 )
    if (vs)
      local fs : String
      local vs_lc = vs.to_lowercase
      forEach (pair in Build.shader_name_pairs)
        fs = find_shader( filepaths, vs_lc, pair.first, pair.last )
        if (fs)
          result.add( @{vs,fs} )
          escapeForEach
        endIf
      endForEach
    else
      local fs = find_shader( filepaths, 1 )
      if (fs)
        println "[WARNING] Fragment shader '$' has no corresponding vertex shader - skipping."(fs)
      else
        filepaths.clear
      endIf
    endIf
  endWhile

  return result
endRoutine

routine find_shader( filepaths:String[], pair_index:Int )->String
  forEach (pair in Build.shader_name_pairs)
    local result = filepaths.remove_first( $.contains(pair[pair_index],&ignore_case) )
    if (result) return result
  endForEach
  return null
endRoutine

routine find_shader( filepaths:String[], filepath:String, replace_old:String, replace_new:String )->String
  local look_for = filepath.replacing( replace_old, replace_new )
  if local match = filepaths.remove_first( $.equals(look_for,&ignore_case) )
    return match
  else
    return null
  endIf
endRoutine

routine rogo_deps
  # SYNTAX: rogo deps [update|rebuild] [sdl]
  local args = System.command_line_arguments.cloned
  local rebuild = args.remove( "rebuild" )
  local update  = args.remove( "update" )
  deps( args, &=update, &=rebuild )
endRoutine

routine deps( args:String[], &update, &rebuild )
  if (Files(".","BuildWarlock.rogue").count == 1)
    banner "ERROR: Rogo should not be run directly in the Warlock library folder."
    System.exit 1
  endIf

  ensure_folder( File("Build/macOS/Assets") )
  ensure_folder( File("Build/macOS/Source") )
  ensure_folder( File("Source") )

  local libs = @{}
  local select_all = false
  loop 2
    if (select_all or args.contains("sdl")) libs//sdl = true
    if (args.count) escapeLoop
    select_all = true
  endLoop

  ensure_folder( File("Libraries") )

  -------- Libraries/SDL --------
  if (select_all or libs//sdl)
    local folder = File("Libraries/SDL")
    local repo = GitRepo( "https://github.com/libsdl-org/SDL.git", folder )

    if (not repo.exists)
      banner "Cloning SDL repo"
      repo.clone( SDL_BRANCH, &verbose )

    elseIf (update)
      if (repo.branch != SDL_BRANCH) repo.checkout( SDL_BRANCH, &verbose )

      if (repo.has_remote_changes)
        banner "Updating SDL repo"
        repo.pull( &verbose )
      endIf
    endIf
  endIf

endRoutine

routine rogo_debug
  rogo_build_debug
  #rogo_run
endRoutine

routine rogo_build( &rebuild )
  #rogo_build_debug( &=rebuild )
  build( System.os, &=rebuild )
endRoutine

routine rogo_rebuild
  rogo_build( &rebuild )
endRoutine

routine rogo_macos
  # SYNTAX: rogo macos [rebuild|release]
  local args = System.command_line_arguments
  #local debug   = args.contains("debug") or not args.contains("release")
  local debug   = args.contains("debug")
  local rebuild = args.contains("rebuild")
  #execute "cd ~/Projects/Rogue && rogo libs"
  #rebuild = true
  build( "macOS", &=debug )
endRoutine

routine rogo_build_debug( &rebuild )
  build( System.os, &debug, &=rebuild )
endRoutine

routine build( platform:String, &debug, &rebuild )
  deps( System.command_line_arguments )
  compile_rogue( platform, &=debug, &=rebuild )
  compile_assets( platform )
endRoutine

routine compile_rogue( platform:String, &debug, &rebuild )
  local files = Files( "Libraries/Warlock/Libraries/Rogue/**.rogue" )
  local source_folder = File("Build/$/Source"(platform)).[create_folder]

  local is_apple = (platform == "macOS" or platform == "iOS")
  local source_filename = "RogueProgram.$"(which{ is_apple:"mm" || "cpp" })
  if (rebuild or files.any_newer_than(source_folder/source_filename))
    block cmd = "roguec Warlock"
      cmd .= appending( "Warlock/SDL" )
      cmd .= appending( "Warlock/BGFX" )
      cmd .= appending( "Warlock/Platform/$.rogue"(platform) )
      if (debug) cmd .= appending( "--debug" )

      local libs = String[]
      libs.add( "Libraries/Warlock/Libraries/Rogue" )
      cmd .= appending( "--libraries=$"(libs.join(',')) )

      local targets = String[]
      targets.add( "C++,Warlock,$"(platform) )
      if (is_apple) targets.add( "ObjC" )
      targets.add( "SDL" )
      targets.add( "bgfx" )
      cmd .= appending( "--target=$"(targets.join(',')) )
      cmd .= appending( "--gc=manual" )
      cmd .= appending( "--output=$/RogueProgram"(source_folder.esc) )
      execute cmd
    endBlock
  endIf
endRoutine

routine compile_assets( platform:String )
  block
    local src  = Files( "Assets/Images/**" )
    local dest = File( "Build/macOS/Assets/Images" )
    src.sync_to( dest, &verbose )
  endBlock

  rogo_shaders( platform )
endRoutine

routine open_xcode( folder:String )
  local listing = File( folder ).listing( "*.xcworkspace" )
  if (listing.is_empty) listing = File( folder ).listing( "*.xcodeproj" )
  if (listing.count)
    execute ''open "$"'' (forEach in listing)
  else
    throw Error( "No .xcodeproj or .xcworkspace folders found." )
  endIf
endRoutine

routine ensure_folder( folder:File )
  if (not folder.exists)
    print_cmd "Create $/"(folder)
    folder.create_folder
  endIf
endRoutine

routine banner( content:String, w=Console.width:Int, &skip )->Logical
  if (skip) return true

  if w == 0 then w = 80

  local n = w.or_smaller(100)
  content .= word_wrapped( n-2 )

  println "┌$┐" ("─"*(n-2))
  forEach (line in content.split('\n'))
    println "│$$│"(line," "*(n-(line.count+2)))
  endForEach
  println "└$┘" ("─"*(n-2))

  return true
endRoutine

routine print_cmd( cmd:String )
  ConsoleStyle.set<<FG_LIGHT_GREEN>>
  print( "> " )
  println( cmd )
  ConsoleStyle.set<<FG_DEFAULT>>
endRoutine

routine execute( commands:String, error_message=null:String, &suppress_error )->Logical
  forEach (cmd in LineReader(commands))
    print_cmd( cmd )
    if (0 != System.run(cmd))
      if (suppress_error)
        return false
      else
        if (not error_message) error_message = "Build failed."
        throw Error( error_message )
      endIf
    endIf
  endForEach
  return true
endRoutine

#-------------------------------------------------------------------------------
# Introspection-based Launcher Framework
#-------------------------------------------------------------------------------
# Rogo is a "build your own build system" facilitator. At its core Rogo just
# recompiles build files if needed and then runs the build executable while
# forwarding any command line arguments. This file contains a default framework
# which uses introspection to turn command line arguments into parameterized
# routine calls.

# Example: to handle the command "rogo abc xyz 5", define
# "routine rogo_abc_xyz( n:Int32 )".

# "rogo_default" will run in the absence of any other command line argument.

# The following "comment directives" can be used in this file to control how
# RogueC compiles it and to manage automatic dependency installation and
# linking.

# Each of the following should be on a line beginning with the characters #$
# (preceding whitespace is fine). Sample args are given.

#   ROGUEC       = roguec       # Path to roguec to compile this file with
#   ROGUEC_ARGS  = --whatever   # Additional options to pass to RogueC
#   CC           = gcc -Wall -fno-strict-aliasing
#   CC_ARGS      = -a -b -c          # Additional C args
#   LINK         = -lalpha -lbeta    # Link this build file with these options
#   LINK(macOS)  = ...               # Options applying only to
#                                    # System.os=="macOS" (use with any OS and
#                                    # any comment directive)
#   LINK_LIBS    = true              # Links following LIBRARIES with this Build
#                                    # file (otherwise just installs them)
#   LINK_LIBS    = false             # Linking turned off for following
#                                    # LIBRARIES - info can still be obtained
#                                    # from $LIBRARY_FLAGS or $LIBRARIES(libname,...)
#   LIBRARIES    = libalpha
#   LIBRARIES    = libbeta(library-name)
#   LIBRARIES    = libfreetype6-dev(freetype2)
#   DEPENDENCIES = Library/Rogue/**/*.rogue
#
#   LIBRARIES    = name(package)
#   LIBRARIES    = name(
#                    exe:<which-name>
#                    exists-cmd:<exists-cmd>
#                    flags:<library-flags>
#                    ignore-exe-only:<setting>
#                    info:<info-name>
#                    info-cmd:<get-info-cmd>
#                    install:<install-name>
#                    install-cmd:<install-cmd>
#                    link:<setting>
#                    package:<package-name>
#                  )
#
# The following macro is replaced within this file (Build.rogue) - the libraries
# should normally also be declared in #$ LIBRARIES:
#
#   $LIBRARY_FLAGS(lib1,lib2)                              # sample macro
#     ->
#   -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...   # sample replacement

routine syntax( command:String, text:String )
  Build.rogo_syntax[ command ] = text
endRoutine

routine description( command:String, text:String )
  Build.rogo_descriptions[ command ] = text
endRoutine

routine help( command:String, description_text=null:String, syntax_text=null:String )
  if (description_text) description( command, description_text )
  if (syntax_text)      syntax( command, syntax_text )
endRoutine

try
  Build.launch
catch (err:Error)
  Build.rogo_error = err
  Build.on_error
endTry

class Build [singleton]
  PROPERTIES
    rogo_syntax         = [String:String]
    rogo_descriptions   = [String:String]
    rogo_prefix         = "rogo_"
    rogo_command        = "default"
    rogo_args           = @[]
    rogo_error          : Error

    LOCAL_SETTINGS_FILE = "Local.rogo"

  METHODS
    method launch
      rogo_args.add( forEach in System.command_line_arguments )
      read_defs
      on_launch
      parse_args
      dispatch_command

    method dispatch_command
      local m = find_command( rogo_command )
      if (not m) throw Error( "No such routine rogo_$()" (rogo_command) )

      local args = @[]
      forEach (arg in rogo_args)
        which (arg)
          case "true":  args.add( true )
          case "false": args.add( false )
          case "null":  args.add( null )
          others:       args.add( arg )
        endWhich
      endForEach
      m( args )

    method find_command( name:String )->MethodInfo
      return <<Routine>>.find_global_method( rogo_prefix + name )

    method on_error
      local w = Console.width.or_smaller( 80 )
      Console.error.println "=" * w
      Console.error.println rogo_error->String.word_wrapped(w)
      Console.error.println "=" * w
      on_exit
      System.exit 1

    method on_command_found
      noAction

    method on_command_not_found
      local w = Console.width.or_smaller( 80 )
      println "=" * w
      println "ERROR: No such command '$'." (rogo_args.first)
      println "=" * w
      println
      rogo_command = "help"
      rogo_args.clear
      on_command_found

    method on_launch
      noAction

    method on_exit
      noAction

    method parse_args
      block
        if (rogo_args.count)
          local parts = String[]
          parts.add( forEach in rogo_args )
          rogo_args.clear

          while (parts.count)
            local cmd = parts.join("_")
            if (find_command(cmd))
              rogo_command = cmd
              on_command_found
              escapeBlock
            endIf
            rogo_args.insert( parts.remove_last )
          endWhile

          on_command_not_found
        endIf

        # Use default command
        on_command_found
      endBlock

    method read_defs
      read_defs( LOCAL_SETTINGS_FILE )

    method read_defs( defs_filepath:String )
      # Attempt to read defs from Local.rogo
      local overrides = String[]
      if (File(defs_filepath).exists)
        forEach (line in LineReader(File(defs_filepath)))
          if (line.contains("="))
            local name  = line.before_first('=').trimmed
            local rhs   = line.after_first('=').trimmed
            local value : Variant
            if (rhs.begins_with('"') or rhs.begins_with('\''))
              value = rhs.leftmost(-1).rightmost(-1)
            elseIf (rhs.begins_with('{') or rhs.begins_with('['))
              value = JSON.parse( rhs )
            else
              value = rhs
            endIf
            local p = <<Build>>.find_property( name )
            if (p)
              overrides.add( "$ = $" (name,value) )
              p.set_value( this, value )
            endIf
          endIf
        endForEach
      endIf

    method _join( value:Variant )->String
      local args = String[]
      args.add( forEach in value )
      return args.join( "_" )
endClass


routine rogo_help( command="":String )
  # SYNTAX: rogo help [command]
  # Displays help for a specified command or else all build commands.
  command = Build._join( Build.rogo_args )
  if (command.count)
    local syntax = get_syntax( command )
    local success = false
    if (syntax)
      println "SYNTAX"
      println "  " + syntax
      println
      success = true
    endIf
    local description = get_description( command )
    if (description)
      description .= replacing("<br>","\n")
      local max_w = Console.width - 2
      println "DESCRIPTION"
      forEach (line in LineReader(description.word_wrapped(max_w)))
        print( "  " )
        println( line )
      endForEach
      println
      success = true
    endIf
    if (success)
      return
    else
      local w = Console.width.or_smaller( 80 )
      println "=" * w
      println "ERROR: No such command '$'." (command)
      println "=" * w
      println
    endIf
  endIf

  println "USAGE"
  local entries = CommandInfo[]
  local max_len = 0
  forEach (m in <<Routine>>.global_methods)
    if (m.name.begins_with(Build.rogo_prefix))
      local name = m.name.after_first( Build.rogo_prefix )
      local entry = CommandInfo( name, get_syntax(name), get_description(name) )
      max_len .= or_larger( entry.syntax.count )
      entries.add entry
    endIf
  endForEach

  entries.sort( $1.name < $2.name )
  max_len += 4

  local max_w = Console.width
  forEach (entry in entries)
    print "  " + entry.syntax
    if (entry.@description)
      local description = entry.@description.before_first( '\n' )
      loop ((max_len - entry.syntax.count) - 2) print ' '
      contingent
        sufficient (max_len + description.count <= max_w)
        if (description.contains(". "))
          description = description.before_first( ". " ) + "."
          sufficient (max_len + description.count <= max_w)
        endIf
        necessary (max_len + 10 <= max_w)
        description = description.unright( (description.count - (max_w - max_len))+5 ) + "..."
      satisfied
        print description
      endContingent
    endIf
    println
  endForEach
  println
endRoutine

routine get_syntax( m_name:String )->String
  if (Build.rogo_syntax.contains(m_name))
    return "rogo " + Build.rogo_syntax[ m_name ]
  else
    local m = <<Routine>>.find_global_method( Build.rogo_prefix + m_name )
    if (not m) return null
    local line = "rogo $" (m_name.replacing('_',' '))
    line += " <$>" ((forEach in m.parameters).name)
    return line
  endIf
endRoutine


routine get_description( m_name:String )->String
  if (Build.rogo_descriptions.contains(m_name))
    return Build.rogo_descriptions[ m_name ]
  else
    return null
  endIf
endRoutine

class CommandInfo( name:String, syntax:String, description:String );
