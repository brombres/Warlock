library Warlock

class Display [singleton]
  AUTO_ID

  PROPERTIES
    state   : DisplayState

    size    : XY  # In pixels.
    density = 1.0 # May be 2 or 3 (etc.) for Retina and other HD displays.

    projection_mode = ProjectionMode2DX : ProjectionMode

    perspective_center : XY
    # The proportional "origin" for 2D+ perspective and the vanishing point for
    # polygons parallel to the camera axis.  Automatically reset to (0.5,0.5)
    # at the beginning of every draw.

    clear_color         = Color.BLACK : Color
    should_clear_color  : Logical

    transform_stack       : TransformStackState  # 'use Display.transform_stack / ... / endUse'
    combined_transform    : Matrix   # projection * view * object
    projection_transform  : Matrix
    view_transform        : Matrix
    transform             : Matrix   # object transform
    transforms            = Matrix[] # object transform stack
    combined_transform_modified    = true

  METHODS
    method at( p:XY )->XY
      return p * size

    method begin_render
      Display = this
      reset

    method bounds->Box
      return Box( size )

    method center->XY
      return size/2

    method change_state( new_state:DisplayState )
      state.change_state( new_state )

    method clear
      should_clear_color = true

    method clear( clear_color )
      should_clear_color = true

    method combined_transform->Matrix
      # projection * world * object
      if (combined_transform_modified)
        combined_transform = projection_transform * view_transform * transform
        combined_transform_modified = false
      endIf
      return @combined_transform

    method draw
      on_draw_bg
      on_draw
      on_draw_fg

    method end_render
      Display = this
      state.on_render_end

    method handle( e:KeyEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method handle( e:PointerEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method handle( e:ScrollEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method handle( e:TextEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method height->Real
      return size.y

    method on( e:KeyEvent )

    method on( e:PointerEvent )

    method on( e:ScrollEvent )

    method on( e:TextEvent )

    method on_unhandled( e:KeyEvent )

    method on_unhandled( e:PointerEvent )

    method on_unhandled( e:ScrollEvent )

    method on_unhandled( e:TextEvent )

    method on_draw

    method on_draw_bg

    method on_draw_fg

    method on_update

    method on_update( dt:Real )

    method push_transform( m:Matrix )
      if (transforms.count)
        transforms.add( transforms.last * m )
      else
        transforms.add( m )
      endIf
      set_transform( transforms.last, &preserve_stack )

    method pop_transform( n=1:Int32 )
      forEach (1..n.or_smaller(transforms.count))
        transforms.remove_last
      endForEach
      if (transforms.count) set_transform( transforms.last, &preserve_stack )
      else                  set_transform( Matrix.identity, &preserve_stack )

    method render
      Display = this

      if (Warlock.delta_ticks)
        loop (Warlock.delta_ticks)
          state = state.updated->(as DisplayState) || DisplayState()
          state.update
        endLoop
      else
        state = state.started || DisplayState()
      endIf
      state.update( Warlock.dt )

      state.on_render_begin
      state.draw

    method reset
      perspective_center = XY(0.5,0.5)
      projection_mode.update
      view_transform   = Matrix.identity
      transform = Matrix.identity
      transforms.clear
      should_clear_color = false

    method safe_area->Box
      return bounds

    method set_perspective_center( new_center:XY )
      if (perspective_center != new_center)
        @perspective_center = new_center
        projection_mode.update
      endIf

    method set_projection_mode( new_mode:ProjectionMode )
      if (projection_mode != new_mode)
        @projection_mode = new_mode
        projection_mode.update
      endIf

    method set_transform( new_transform:Matrix, &preserve_stack )
      if (not preserve_stack) transforms.clear
      if (transform != new_transform)
        <Display.transform_modified>.signal
        @transform = new_transform
        combined_transform_modified = true
      endIf

    method set_projection_transform( new_transform:Matrix )
      if (projection_transform != new_transform)
        <Display.transform_modified>.signal
        @projection_transform = new_transform
        combined_transform_modified = true
      endIf

    method set_view_transform( new_transform:Matrix )
      if (view_transform != new_transform)
        <Display.transform_modified>.signal
        @view_transform = new_transform
        combined_transform_modified = true
      endIf

    method update
      on_update

    method update( dt:Real )
      on_update( dt )

    method width->Real
      return size.x

endClass

class TransformStackState( original_stack_count:Int ) [compound]
  METHODS
    method on_use->this [mutating]
      original_stack_count = Display.transforms.count
      return this

    method on_end_use( state:TransformStackState )
      local n = Display.transforms.count - state.original_stack_count
      if (n) Display.pop_transform( n )
endClass
