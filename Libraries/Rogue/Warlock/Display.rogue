library Warlock

class Display [singleton]
  AUTO_ID

  PROPERTIES
    state   : DisplayState
    ui      = UI()

    pixel_size        : XY  # True size in pixels.
    size              : XY  # Scaled size.
    scale_to_fit_size : XY?
    density = 1.0 # May be 2 or 3 (etc.) for Retina and other HD displays.

    projection_mode = ProjectionMode2DX : ProjectionMode

    perspective_center : XY
    # The proportional "origin" for 2D+ perspective and the vanishing point for
    # polygons parallel to the camera axis.  Automatically reset to (0.5,0.5)
    # at the beginning of every draw.

    clear_color         = Color.BLACK : Color
    should_clear_color  : Logical

    transform_stack       : TransformStackState  # 'use Display.transform_stack / ... / endUse'
    combined_transform    : Matrix   # projection * world
    world_transform       : Matrix   # view * object
    projection_transform  : Matrix
    view_transform        : Matrix
    transform             : Matrix   # object transform
    transforms            = Matrix[] # object transform stack
    combined_transform_modified = true
    world_transform_modified    = true

    clip                  : Box?
    clip_stack            = Box?[]

  GLOBAL METHODS
    method on_singleton_change( old_display:Display, new_display:Display, &before )
      if (before) Renderer.flush
      else        Renderer.display_id = new_display.id

  METHODS
    method on_cleanup
      IDManager.return_id( this )

  METHODS
    method at( p:XY )->XY
      return p * size

    method begin_render
      Display = this
      reset

    method bounds->Box
      return Box( size )

    method center->XY
      return size/2

    method change_state( new_state:DisplayState )
      if (state) state.change_state( new_state )
      else       state = new_state

    method clear
      should_clear_color = true

    method clear( clear_color )
      should_clear_color = true

    method clear_clip
      clip_stack.clear
      clip = null

    method combined_transform->Matrix
      # projection * world * object
      if (combined_transform_modified)
        combined_transform = projection_transform * world_transform
        combined_transform_modified = false
      endIf
      return @combined_transform

    method draw
      on_draw( &bg )
      on_draw
      ui.draw
      on_draw( &!bg )

    method end_render
      Display = this
      state?.on_render_end

    method handle( e:KeyEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        ui.handle( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method handle( e:PointerEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        ui.handle( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method handle( e:ScrollEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        ui.handle( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method handle( e:TextEvent )
      contingent
        on( e )
        necessary (not e.is_consumed)

        ui.handle( e )
        necessary (not e.is_consumed)

        on_unhandled( e )
      endContingent

    method height->Real
      return size.y

    method on( e:KeyEvent )

    method on( e:PointerEvent )

    method on( e:ScrollEvent )

    method on( e:TextEvent )

    method on_unhandled( e:KeyEvent )

    method on_unhandled( e:PointerEvent )

    method on_unhandled( e:ScrollEvent )

    method on_unhandled( e:TextEvent )

    method on_draw

    method on_draw( &bg )

    method on_update

    method on_update( dt:Real )

    method pop_clip( n=1:Int )
      if (n >= 1 and n >= clip_stack.count)
        clip_stack.discard_last( n - 1 )
        clip = clip_stack.remove_last
      endIf

    method push_transform( m:Matrix )
      if (transforms.count)
        transforms.add( transforms.last * m )
      else
        transforms.add( m )
      endIf
      set_transform( transforms.last, &preserve_stack )

    method pop_transform( n=1:Int32 )
      forEach (1..n.or_smaller(transforms.count))
        transforms.remove_last
      endForEach
      if (transforms.count) set_transform( transforms.last, &preserve_stack )
      else                  set_transform( Matrix.identity, &preserve_stack )

    method push_clip( new_clip:Box? )
      clip_stack.add( clip )

      if (new_clip)
        if (clip)
          new_clip = clip.value & new_clip.value
          if (not new_clip)
            # No interesection, but don't use 'null' as that means "no clip".
            new_clip = Box(0,0,0,0)
          endIf
        endIf
      endIf

      clip = new_clip

    method render
      Display = this

      state = state?.updated || DisplayState()
      state.on_render_begin
      state.draw

    method reset
      perspective_center = XY(0.5,0.5)
      view_transform   = Matrix.identity
      transform = Matrix.identity
      transforms.clear
      should_clear_color = false
      update_size
      clear_clip

    method safe_area->Box
      return bounds

    method scale_to_fit( scale_to_fit_size )
      update_size

    method set_clip( new_clip:Box? )
      if (clip != new_clip)
        Renderer.flush
        @clip = new_clip
      endIf

    method set_perspective_center( new_center:XY )
      if (perspective_center != new_center)
        @perspective_center = new_center
        projection_mode.update
      endIf

    method set_projection_mode( new_mode:ProjectionMode )
      if (projection_mode != new_mode)
        @projection_mode = new_mode
        projection_mode.update
      endIf

    method set_transform( new_transform:Matrix, &preserve_stack )
      if (not preserve_stack) transforms.clear
      if (transform != new_transform)
        <Display.transform_modified>.signal
        @transform = new_transform
        combined_transform_modified = true
        world_transform_modified = true
      endIf

    method set_pixel_size( new_pixel_size:XY )
      if (pixel_size != new_pixel_size)
        @pixel_size = new_pixel_size
        update_size
      endIf

    method set_projection_transform( new_transform:Matrix )
      if (projection_transform != new_transform)
        <Display.transform_modified>.signal
        @projection_transform = new_transform
        combined_transform_modified = true
      endIf

    method set_view_transform( new_transform:Matrix )
      if (view_transform != new_transform)
        <Display.transform_modified>.signal
        @view_transform = new_transform
        combined_transform_modified = true
        world_transform_modified = true
      endIf

    method update
      on_update

    method update( dt:Real )
      on_update( dt )
      ui.update( bounds )
      ui.request_redraw

    method update_size
      Renderer.flush
      if local fit_size = scale_to_fit_size
        local scale = (fit_size / pixel_size).min
        size = (pixel_size * scale).floor
      else
        size = pixel_size
      endIf
      projection_mode.update

    method width->Real
      return size.x

    method world_transform->Matrix
      # projection * world * object
      if (world_transform_modified)
        world_transform = view_transform * transform
        world_transform_modified = false
      endIf
      return @world_transform

endClass

class TransformStackState( original_stack_count:Int ) [compound]
  METHODS
    method on_use->this [mutating]
      original_stack_count = Display.transforms.count
      return this

    method on_end_use( state:TransformStackState )
      local n = Display.transforms.count - state.original_stack_count
      if (n) Display.pop_transform( n )
endClass
