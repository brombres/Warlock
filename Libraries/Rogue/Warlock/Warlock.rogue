library Warlock

nativeHeader @|#include "WarlockInterface.h"

$include Warlock/AssetInfo
$include Warlock/AssetManifest
$include Warlock/BitmapIO
$include Warlock/Box
$include Warlock/Macros
$include Warlock/Display
$include Warlock/DisplayState
$include Warlock/Drawable2D
$include Warlock/RendererBatch
$include Warlock/Framework
$include Warlock/IDGenerator
$include Warlock/Image
$include Warlock/ImageInfo
$include Warlock/Line
$include Warlock/Log
$include Warlock/MeshBuilder
$include Warlock/ProjectionMode
$include Warlock/Renderer
$include Warlock/Scene
$include Warlock/SceneState
$include Warlock/Shader
$include Warlock/State
$include Warlock/Texture
$include Warlock/Triangle
$include Warlock/UpdateRegulator
$include Warlock/Vertex
$include Warlock/View
$include Warlock/ViewState
$include Warlock/Window

uses Control/State
uses Entity
uses Geometry [export]
uses Graphics [export]
uses Math/Matrix
uses UI
uses Utility/Timer

State = State() subclass
  PROPERTIES
    angle   : Degrees
    image   : Image
    child   : Image
    timer   = Timer()

  METHODS
    method on_start
      if local file = Warlock.find_asset( "Assets/Images/Hannah-and-Burf.jpg" )
        #if local file = Warlock.find_asset( "Assets/Images/123.png" )
        local texture = Texture( Texture(file) )
        image = Image( texture )
        child = Image(XY(256,256),Color.YELLOW).[position=XY(128,128)]
        child.add( Image(texture).[size=XY(120,120), position=XY(128,128)] )
        image.add( child )
      endIf
      Display.clear( Color.BLUE )

    method on_draw
      Display.projection_mode = ProjectionMode2DX
      Display.perspective_center = XY(0.5,0.25)
      Display.clear

      image.anchor = Anchor.CENTER
      image.internal_size = XY(512)
      image.scale_to_fill(Display.bounds)
      image.rotation = 0
      #image.draw( Display.center )

      #Display.bounds.fill( Color.BLACK.with_opacity(0.5) )
      #image.scale_to_fit(Display.bounds)
      image.size = XY(256)
      image.rotation = angle
      image.draw( Display.center )
      angle += 1
      child.rotation += Degrees(1.5)

      Line(  1, 0, 1, Display.height ).draw( Color(0xFF88FF88) )
      Line(  3, 0, 3, Display.height ).draw( Color(0xFF88FF88) )
      Line(  5, 0, 5, Display.height ).draw( Color(0xFF88FF88) )
      Line(  7, 0, 7, Display.height ).draw( Color(0xFF88FF88) )
      Line(  9, 0, 9, Display.height ).draw( Color(0xFF88FF88) )
      Line( 11, 0,11, Display.height ).draw( Color(0xFF88FF88) )
      Line( 13, 0,13, Display.height ).draw( Color(0xFF88FF88) )
      Line( 15, 0,15, Display.height ).draw( Color(0xFF88FF88) )

    method on( e:KeyEvent )
      trace e

endSubclass

class Warlock [essential singleton]
  GLOBAL METHODS
    method configure [api]
      Warlock.on_configure

    method update->Logical [api]
      # Ensure consistent state references are set before updating events
      State.current = State
      forEach (window in Warlock.windows)
        window.current_state = window.state
      endForEach

      local keep_running = Framework.update_events

      Warlock.render
      return keep_running

  PROPERTIES
    configured     : Logical
    windows        = Window[]

    update_regulator = UpdateRegulator()
    dt               : Real     # Delta Time - seconds since previous frame (may be 0.0)
    delta_ticks      : Int      # Ticks applied this frame (may be 0)
    ticks            : Int      # Lifetime tick count
    frames           : Int      # Lifetime frame count
    fps              = 60       # Current fps

  METHODS
    method init
      println "Initializing Warlock"
      <Display.transform_modified>.on_signal( () => Renderer.flush )

    method add_window( window:Window )
      windows.add( window )

    method find_asset( name:String )->File?
      local filepath = native("WarlockInterface_find_asset($name)")->String
      if (filepath) return File( filepath )
      else          return null

      #{
    method find_image( name:String )->File?
      if local result = find_asset( name )
        return File(result)
      endIf

      if (not name.begins_with("Assets/"))
        if (name.begins_with("Images/")) name = "Assets"/name
        else                             name = "Assets/Images"/name
      endIf

      if local result = find_asset( name )
        return File(result)
      endIf

      forEach (ext in image_extensions)
        local filepath = "$.$"(name,ext)
        if local result = find_asset( filepath )
          return File(result)
        endIf
      endForEach

      return null
      }#

    method find_window( id=null:Int?, native_id=null:Int? )->Window
      if local native_id = native_id
        forEach (window in windows)
          if (window.native_id == native_id) return window
        endForEach
      endIf

      if local id = id
        forEach (window in windows)
          if (window.id == id) return window
        endForEach
      endIf

      return null

    method load_asset_bytes( filepath:String )->Byte[]
      if (filepath) return Byte[]( File(filepath) )
      else          return null

    method on_configure
      AssetManifest.load

      if (windows.is_empty)
        Window( "Warlock", 640, 360 )
      endIf

    method render
      ++frames
      update_regulator.update

      (forEach in windows).begin_render

      loop (delta_ticks)
        State = State.updated || State()
      endLoop
      State.current = State  # ensure consistent state throughout render process, even after state change
      State.current.on_update( dt )

      State.current.on_render
      (forEach in windows).render

      State.current.on_end_render
      (forEach in windows).end_render

endClass
