library Warlock

nativeHeader @|#include "WarlockInterface.h"

$include Warlock/Macros
$include Warlock/Display
$include Warlock/DisplayState
$include Warlock/DrawCommand
$include Warlock/Framework
$include Warlock/IDGenerator
$include Warlock/Line
$include Warlock/MeshBuilder
$include Warlock/ProjectionMode
$include Warlock/Renderer
$include Warlock/Scene
$include Warlock/SceneState
$include Warlock/Shader
$include Warlock/State
$include Warlock/Vertex
$include Warlock/View
$include Warlock/ViewState
$include Warlock/Window

uses Control/State
uses Geometry [export]
uses Graphics [export]
uses Math/Matrix
uses UI

State = State() subclass
  PROPERTIES
    swap_index : Int

  METHODS
    method on_draw
      Display.projection_mode = ProjectionModePerspective
      Display.push_view_transform( Matrix.look_at(XYZ(0,0,-5), XYZ.zero) )
      Display.push_object_transform( Matrix.rotate_xy(RadiansXY(Renderer.frame*0.01, Renderer.frame*0.01 )) )

      #{
      which (swap_index)
        case 0: Line( XY(-1,-1), XY( 1,-1) ).draw( Color.WHITE )
        case 1: Line( XY(-1,-1), XY( 1, 1) ).draw( Color.WHITE )
        case 2: Line( XY(-1,-1), XY(-1, 1) ).draw( Color.WHITE )
      endWhich
      swap_index = (swap_index + 1) % 3
      }#

      #{
      Renderer.draw_triangles
      Renderer.data.add Vertex( XYZ(-1, 1,-1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ( 1, 1,-1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ(-1,-1,-1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ( 1,-1,-1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ(-1, 1, 1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ( 1, 1, 1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ(-1,-1, 1), Color(0xFF333366) )
      Renderer.data.add Vertex( XYZ( 1,-1, 1), Color(0xFF333366) )
      Renderer.data.add( 0, 1, 2 )
      Renderer.data.add( 1, 3, 2 )
      Renderer.data.add( 4, 6, 5 )
      Renderer.data.add( 5, 6, 7 )
      Renderer.data.add( 0, 2, 4 )
      Renderer.data.add( 4, 2, 6 )
      Renderer.data.add( 1, 5, 3 )
      Renderer.data.add( 5, 7, 3 )
      Renderer.data.add( 0, 4, 1 )
      Renderer.data.add( 4, 5, 1 )
      Renderer.data.add( 2, 3, 6 )
      Renderer.data.add( 6, 3, 7 )
      }#

      Renderer.draw_lines
      Renderer.data.add Vertex( XYZ(-1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add( 0, 1 )
      Renderer.data.add( 1, 3 )
      Renderer.data.add( 3, 2 )
      Renderer.data.add( 2, 0 )

      Renderer.data.add( 4, 5 )
      Renderer.data.add( 5, 7 )
      Renderer.data.add( 7, 6 )
      Renderer.data.add( 6, 4 )

      Renderer.data.add( 0, 4 )
      Renderer.data.add( 1, 5 )
      Renderer.data.add( 2, 6 )
      Renderer.data.add( 3, 7 )

endSubclass

class Warlock [essential singleton]
  GLOBAL PROPERTIES
    mesh = MeshBuilder()

  GLOBAL METHODS
    method configure [api]
      Warlock.on_configure

    method m_proj->Matrix [api]
      return Matrix.perspective(
        Degrees(60),
        1280.0/720.0,
        0.1, 100,
        &homogeneous_depth=Renderer.uses_homogeneous_depth
      )

    method m_view->Matrix [api]
      return Matrix.look_at( XYZ(0,0,-5), XYZ.zero )

    method m_xform( n:Int )->Matrix [api]
      return Matrix.rotate_xy( RadiansXY( n*0.01, n*0.01 ) )

    method get_mesh->MeshBuilder [api]
      return mesh

    method render [api]
      Warlock.on_render

  PROPERTIES
    configured            : Logical
    windows               = Window[]

  METHODS
    method init
      println "Initializing Warlock"
      <Display.transform_modified>.on_signal( () => Renderer.flush )

      mesh.add( Vertex(XYZ(-1, 1,-1), Color.BLACK) )
      mesh.add( Vertex(XYZ( 1, 1,-1), Color.RED ) )
      mesh.add( Vertex(XYZ(-1,-1,-1), Color.GREEN) )
      mesh.add( Vertex(XYZ( 1,-1,-1), Color.YELLOW) )
      mesh.add( Vertex(XYZ(-1, 1, 1), Color.BLUE) )
      mesh.add( Vertex(XYZ( 1, 1, 1), Color.MAGENTA) )
      mesh.add( Vertex(XYZ(-1,-1, 1), Color.CYAN) )
      mesh.add( Vertex(XYZ( 1,-1, 1), Color.WHITE) )
      mesh.add(
        [
          0, 1, 2,
          1, 3, 2,
          4, 6, 5,
          5, 6, 7,
          0, 2, 4,
          4, 2, 6,
          1, 5, 3,
          5, 7, 3,
          0, 4, 1,
          4, 5, 1,
          2, 3, 6,
          6, 3, 7
        ]
      )

    method add_window( window:Window )
      windows.add( window )

    method find_asset( name:String )->File?
      local filepath = native("WarlockInterface_find_asset($name)")->String
      if (filepath) return File( filepath )
      else          return null

      #{
    method find_image( name:String )->File?
      if local result = find_asset( name )
        return File(result)
      endIf

      if (not name.begins_with("Assets/"))
        if (name.begins_with("Images/")) name = "Assets"/name
        else                             name = "Assets/Images"/name
      endIf

      if local result = find_asset( name )
        return File(result)
      endIf

      forEach (ext in image_extensions)
        local filepath = "$.$"(name,ext)
        if local result = find_asset( filepath )
          return File(result)
        endIf
      endForEach

      return null
      }#

    method load_asset_bytes( filepath:String )->Byte[]
      if (filepath) return Byte[]( File(filepath) )
      else          return null

    method on_configure
      if (windows.is_empty)
        Window( "Warlock", 1280, 720 )
      endIf

    method on_render
      State = State.updated || State()
      State.current = State  # ensure consistent state throughout render process, even after state change
      State.current.on_render
      (forEach in windows).render
      State.current.on_end_render

endClass
