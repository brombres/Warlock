library Warlock

nativeHeader @|#include "WarlockInterface.h"

$include Warlock/BitmapIO
$include Warlock/Box
$include Warlock/Macros
$include Warlock/Display
$include Warlock/DisplayState
$include Warlock/RenderBatch
$include Warlock/Framework
$include Warlock/IDGenerator
$include Warlock/Image
$include Warlock/Line
$include Warlock/MeshBuilder
$include Warlock/ProjectionMode
$include Warlock/Renderer
$include Warlock/Scene
$include Warlock/SceneState
$include Warlock/Shader
$include Warlock/State
$include Warlock/Texture
$include Warlock/Triangle
$include Warlock/Vertex
$include Warlock/View
$include Warlock/ViewState
$include Warlock/Window

uses Control/State
uses Geometry [export]
uses Graphics [export]
uses Math/Matrix
uses UI

State = State() subclass
  PROPERTIES
    angle   : Degrees
    texture : Texture

  METHODS
    method on_start
      if local file = Warlock.find_asset( "Assets/Images/Hannah-and-Burf.jpg" )
        #if local file = Warlock.find_asset( "Assets/Images/123.png" )
        texture = Texture( file )
        #local bmp = Bitmap( file )
        #bmp.swap_red_and_blue
      endIf

    method on_draw
      Display.projection_mode = ProjectionMode2DX

      Box(  0,  0,128,128).fill( Color.ORANGE )
      Box( 32, 32,128,128).fill( texture )
      Box( 64, 64,128,128).fill( Color.GREEN )
      Box( 96, 96,128,128).fill( Color.YELLOW )
      Line( 0,  0,192,192).draw( Color.WHITE )
      #Box(321,321,512,512).fill( texture, Color(0xeeeeeeee) )
      #Box(320,320,512,512).fill( Color.WHITE )

      #{
      local len = Display.size.min * 0.45
      local triangle = Triangle(
        XY( len, Degrees(30) ),
        XY( len, Degrees(150) ),
        XY( len, Degrees(270) )
      ).rotated( angle ) + Display.center
      }#

      #triangle.fill( Color.CYAN )
      #triangle.draw( Color.WHITE )
      #triangle.fill( texture )


      #{
      Renderer.draw_lines
      Renderer.data.add Vertex( XYZ(-1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add( 0, 1 )
      Renderer.data.add( 1, 3 )
      Renderer.data.add( 3, 2 )
      Renderer.data.add( 2, 0 )

      Renderer.data.add( 4, 5 )
      Renderer.data.add( 5, 7 )
      Renderer.data.add( 7, 6 )
      Renderer.data.add( 6, 4 )

      Renderer.data.add( 0, 4 )
      Renderer.data.add( 1, 5 )
      Renderer.data.add( 2, 6 )
      Renderer.data.add( 3, 7 )
      }#

      #{
      Renderer.draw_triangles
      Renderer.data.add( 0, 1, 2 )
      Renderer.data.add( 1, 3, 2 )
      Renderer.data.add( 4, 6, 5 )
      Renderer.data.add( 5, 6, 7 )
      Renderer.data.add( 0, 2, 4 )
      Renderer.data.add( 4, 2, 6 )
      Renderer.data.add( 1, 5, 3 )
      Renderer.data.add( 5, 7, 3 )
      Renderer.data.add( 0, 4, 1 )
      Renderer.data.add( 4, 5, 1 )
      Renderer.data.add( 2, 3, 6 )
      Renderer.data.add( 6, 3, 7 )
      }#

    method on_update


endSubclass

class Warlock [essential singleton]
  GLOBAL PROPERTIES
    mesh = MeshBuilder()

  GLOBAL METHODS
    method configure [api]
      Warlock.on_configure

    method m_proj->Matrix [api]
      return Matrix.perspective(
        Degrees(60),
        1280.0/720.0,
        0.1, 100,
        &homogeneous_depth=Renderer.uses_homogeneous_depth
      )

    method m_view->Matrix [api]
      return Matrix.look_at( XYZ(0,0,-5), XYZ.zero )

    method m_xform( n:Int )->Matrix [api]
      return Matrix.rotate_xy( RadiansXY( n*0.01, n*0.01 ) )

    method get_mesh->MeshBuilder [api]
      return mesh

    method render [api]
      Warlock.on_render

  PROPERTIES
    configured            : Logical
    windows               = Window[]

  METHODS
    method init
      println "Initializing Warlock"
      <Display.transform_modified>.on_signal( () => Renderer.flush )

      mesh.add( Vertex(XYZ(-1, 1,-1), Color.BLACK) )
      mesh.add( Vertex(XYZ( 1, 1,-1), Color.RED ) )
      mesh.add( Vertex(XYZ(-1,-1,-1), Color.GREEN) )
      mesh.add( Vertex(XYZ( 1,-1,-1), Color.YELLOW) )
      mesh.add( Vertex(XYZ(-1, 1, 1), Color.BLUE) )
      mesh.add( Vertex(XYZ( 1, 1, 1), Color.MAGENTA) )
      mesh.add( Vertex(XYZ(-1,-1, 1), Color.CYAN) )
      mesh.add( Vertex(XYZ( 1,-1, 1), Color.WHITE) )
      mesh.add(
        [
          0, 1, 2,
          1, 3, 2,
          4, 6, 5,
          5, 6, 7,
          0, 2, 4,
          4, 2, 6,
          1, 5, 3,
          5, 7, 3,
          0, 4, 1,
          4, 5, 1,
          2, 3, 6,
          6, 3, 7
        ]
      )

    method add_window( window:Window )
      windows.add( window )

    method find_asset( name:String )->File?
      local filepath = native("WarlockInterface_find_asset($name)")->String
      if (filepath) return File( filepath )
      else          return null

      #{
    method find_image( name:String )->File?
      if local result = find_asset( name )
        return File(result)
      endIf

      if (not name.begins_with("Assets/"))
        if (name.begins_with("Images/")) name = "Assets"/name
        else                             name = "Assets/Images"/name
      endIf

      if local result = find_asset( name )
        return File(result)
      endIf

      forEach (ext in image_extensions)
        local filepath = "$.$"(name,ext)
        if local result = find_asset( filepath )
          return File(result)
        endIf
      endForEach

      return null
      }#

    method load_asset_bytes( filepath:String )->Byte[]
      if (filepath) return Byte[]( File(filepath) )
      else          return null

    method on_configure
      if (windows.is_empty)
        Window( "Warlock", 1280, 720 )
      endIf

    method on_render
      State = State.updated || State()
      State.current = State  # ensure consistent state throughout render process, even after state change
      State.current.on_render
      (forEach in windows).render
      State.current.on_end_render

endClass
