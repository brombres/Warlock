library Warlock

nativeHeader @|#include "WarlockInterface.h"

$include Warlock/Box
$include Warlock/Macros
$include Warlock/Display
$include Warlock/DisplayState
$include Warlock/DrawCommand
$include Warlock/Framework
$include Warlock/IDGenerator
$include Warlock/Line
$include Warlock/MeshBuilder
$include Warlock/ProjectionMode
$include Warlock/Renderer
$include Warlock/Scene
$include Warlock/SceneState
$include Warlock/Shader
$include Warlock/State
$include Warlock/Vertex
$include Warlock/View
$include Warlock/ViewState
$include Warlock/Window

uses Control/State
uses Geometry [export]
uses Graphics [export]
uses Math/Matrix
uses UI

nativeCode
@|
 |inline void mtxFrustum(float* _result, float _left, float _right, float _bottom, float _top, float _near, float _far)
 |{
 |    const float inv_width  = 1.0f / (_right - _left);
 |    const float inv_height = 1.0f / (_top - _bottom);
 |    const float inv_depth  = 1.0f / (_far - _near);
 |
 |    _result[ 0] = 2.0f * _near * inv_width;
 |    _result[ 1] = 0.0f;
 |    _result[ 2] = 0.0f;
 |    _result[ 3] = 0.0f;
 |
 |    _result[ 4] = 0.0f;
 |    _result[ 5] = 2.0f * _near * inv_height;
 |    _result[ 6] = 0.0f;
 |    _result[ 7] = 0.0f;
 |
 |    _result[ 8] = (_right + _left) * inv_width;
 |    _result[ 9] = (_top + _bottom) * inv_height;
 |    _result[10] = -_far * inv_depth;
 |    _result[11] = -1.0f;
 |
 |    _result[12] = 0.0f;
 |    _result[13] = 0.0f;
 |    _result[14] = -(_far * _near) * inv_depth;
 |    _result[15] = 0.0f;
 |}
 |
 |void createFrustumMatrix(
 |    float* result,
 |    float left,
 |    float right,
 |    float bottom,
 |    float top,
 |    float near,
 |    float far
 |) {
 |    result[0]  = 2.0f * near / (right - left);
 |    result[1]  = 0.0f;
 |    result[2]  = 0.0f;
 |    result[3]  = 0.0f;
 |
 |    result[4]  = 0.0f;
 |    result[5]  = 2.0f * near / (top - bottom);
 |    result[6]  = 0.0f;
 |    result[7]  = 0.0f;
 |
 |    result[8]  = (right + left) / (right - left);
 |    result[9]  = (top + bottom) / (top - bottom);
 |    result[10] = far / (near - far); // Adjusted for [0, 1] depth range
 |    result[11] = -1.0f;
 |
 |    result[12] = 0.0f;
 |    result[13] = 0.0f;
 |    result[14] = (far * near) / (near - far); // Adjusted for [0, 1] depth range
 |    result[15] = 0.0f;
 |}
 |/*
 |void createFrustumMatrix(
 |    float* result,
 |    float left,
 |    float right,
 |    float bottom,
 |    float top,
 |    float near,
 |    float far
 |) {
 |    result[0]  = 2.0f * near / (right - left);
 |    result[1]  = 0.0f;
 |    result[2]  = 0.0f;
 |    result[3]  = 0.0f;
 |
 |    result[4]  = 0.0f;
 |    result[5]  = 2.0f * near / (top - bottom);
 |    result[6]  = 0.0f;
 |    result[7]  = 0.0f;
 |
 |    result[8]  = (right + left) / (right - left);
 |    result[9]  = (top + bottom) / (top - bottom);
 |    result[10] = -(far + near) / (far - near);
 |    result[11] = -1.0f;
 |
 |    result[12] = 0.0f;
 |    result[13] = 0.0f;
 |    result[14] = -(2.0f * far * near) / (far - near);
 |    result[15] = 0.0f;
 |}
 |*/

State = State() subclass
  PROPERTIES
    swap_index : Int

  METHODS
    method on_draw
      Display.projection_mode = ProjectionMode2DX
      #Display.projection_transform = Matrix.frustum( 0, Display.width, Display.height, 0, 0.1, 100 ) * Matrix.translate( XYZ(0,0,-0.1) )
      #Line<<XYZ>>( XYZ(0,0,-5), XYZ(Display.width,Display.height,5) ).draw( Color.WHITE )

      #local w = Display.width->Int32
      #local h = Display.height->Int32
      #local m32 : Matrix32
      #native @|bx::mtxOrtho( reinterpret_cast<float*>(&$m32), 0, $w-1, $h-1, 0, -1, 1, 0, false, bx::Handedness::Right );
      #native @|createFrustumMatrix( reinterpret_cast<float*>(&$m32), -1, 1, -1, 1, 1, -1 );
      #native @|createFrustumMatrix( reinterpret_cast<float*>(&$m32), -1, 1, -1, 1, 0.1f, 100.0f );

               #Display.projection_transform = m32->Matrix
               #println "FRUSTUM"
               #println Display.projection_transform
               #println

      #Display.projection_transform = Matrix.identity
      #local m = Display.projection_transform
      #@trace m * -XYZ(-1,-1,-0.5)
      #@trace m *  XYZ(1,1,-0.5)

      #{
      println "BX"
      println Display.projection_transform
      println
      }#

      #{
      Display.projection_transform = Matrix.orthographic(
        -1,
         1, #Display.width-1,
        -1,  #Display.height-1,
         1,
        -1,
         1
      )
      println "ORTHO"
      println Display.projection_transform
      println
      }#

      Box( Display.bounds ).fill( Color.YELLOW )
      Box( Display.bounds.cropped(1) ).fill( Color.RED )
      #Line( Display.at(XY(0.5,0)).floor+XY(0,1), Display.at(XY(0.5,1)).floor-XY(0,2) ).draw( Color.WHITE )
      #Line( Display.at(XY(0,0.5)).floor+XY(1,0), Display.at(XY(1,0.5)).floor-XY(2,0) ).draw( Color.WHITE )
      #Line<<XYZ>>( XYZ(-Display.size,-0.1), XYZ(Display.size,-0.1) ).draw( Color.WHITE )
      #Line( Display.at(XY(0,0.5)).floor+XY(1,0), Display.at(XY(1,0.5)).floor-XY(2,0) ).draw( Color.WHITE )

      #Display.projection_mode = ProjectionModePerspective
      #Display.push_view_transform( Matrix.look_at(XYZ(0,0,-5), XYZ.zero) )
      #Display.push_object_transform( Matrix.rotate_xy(RadiansXY(Renderer.frame*0.01, Renderer.frame*0.01 )) )

      #{
      Renderer.draw_lines
      Renderer.data.add Vertex( XYZ(-1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add( 0, 1 )
      Renderer.data.add( 1, 3 )
      Renderer.data.add( 3, 2 )
      Renderer.data.add( 2, 0 )

      Renderer.data.add( 4, 5 )
      Renderer.data.add( 5, 7 )
      Renderer.data.add( 7, 6 )
      Renderer.data.add( 6, 4 )

      Renderer.data.add( 0, 4 )
      Renderer.data.add( 1, 5 )
      Renderer.data.add( 2, 6 )
      Renderer.data.add( 3, 7 )
      }#

      #{
      Renderer.draw_triangles
      Renderer.data.add( 0, 1, 2 )
      Renderer.data.add( 1, 3, 2 )
      Renderer.data.add( 4, 6, 5 )
      Renderer.data.add( 5, 6, 7 )
      Renderer.data.add( 0, 2, 4 )
      Renderer.data.add( 4, 2, 6 )
      Renderer.data.add( 1, 5, 3 )
      Renderer.data.add( 5, 7, 3 )
      Renderer.data.add( 0, 4, 1 )
      Renderer.data.add( 4, 5, 1 )
      Renderer.data.add( 2, 3, 6 )
      Renderer.data.add( 6, 3, 7 )
      }#


endSubclass

class Warlock [essential singleton]
  GLOBAL PROPERTIES
    mesh = MeshBuilder()

  GLOBAL METHODS
    method configure [api]
      Warlock.on_configure

    method m_proj->Matrix [api]
      return Matrix.perspective(
        Degrees(60),
        1280.0/720.0,
        0.1, 100,
        &homogeneous_depth=Renderer.uses_homogeneous_depth
      )

    method m_view->Matrix [api]
      return Matrix.look_at( XYZ(0,0,-5), XYZ.zero )

    method m_xform( n:Int )->Matrix [api]
      return Matrix.rotate_xy( RadiansXY( n*0.01, n*0.01 ) )

    method get_mesh->MeshBuilder [api]
      return mesh

    method render [api]
      Warlock.on_render

  PROPERTIES
    configured            : Logical
    windows               = Window[]

  METHODS
    method init
      println "Initializing Warlock"
      <Display.transform_modified>.on_signal( () => Renderer.flush )

      mesh.add( Vertex(XYZ(-1, 1,-1), Color.BLACK) )
      mesh.add( Vertex(XYZ( 1, 1,-1), Color.RED ) )
      mesh.add( Vertex(XYZ(-1,-1,-1), Color.GREEN) )
      mesh.add( Vertex(XYZ( 1,-1,-1), Color.YELLOW) )
      mesh.add( Vertex(XYZ(-1, 1, 1), Color.BLUE) )
      mesh.add( Vertex(XYZ( 1, 1, 1), Color.MAGENTA) )
      mesh.add( Vertex(XYZ(-1,-1, 1), Color.CYAN) )
      mesh.add( Vertex(XYZ( 1,-1, 1), Color.WHITE) )
      mesh.add(
        [
          0, 1, 2,
          1, 3, 2,
          4, 6, 5,
          5, 6, 7,
          0, 2, 4,
          4, 2, 6,
          1, 5, 3,
          5, 7, 3,
          0, 4, 1,
          4, 5, 1,
          2, 3, 6,
          6, 3, 7
        ]
      )

    method add_window( window:Window )
      windows.add( window )

    method find_asset( name:String )->File?
      local filepath = native("WarlockInterface_find_asset($name)")->String
      if (filepath) return File( filepath )
      else          return null

      #{
    method find_image( name:String )->File?
      if local result = find_asset( name )
        return File(result)
      endIf

      if (not name.begins_with("Assets/"))
        if (name.begins_with("Images/")) name = "Assets"/name
        else                             name = "Assets/Images"/name
      endIf

      if local result = find_asset( name )
        return File(result)
      endIf

      forEach (ext in image_extensions)
        local filepath = "$.$"(name,ext)
        if local result = find_asset( filepath )
          return File(result)
        endIf
      endForEach

      return null
      }#

    method load_asset_bytes( filepath:String )->Byte[]
      if (filepath) return Byte[]( File(filepath) )
      else          return null

    method on_configure
      if (windows.is_empty)
        Window( "Warlock", 1280, 720 )
      endIf

    method on_render
      State = State.updated || State()
      State.current = State  # ensure consistent state throughout render process, even after state change
      State.current.on_render
      (forEach in windows).render
      State.current.on_end_render

endClass
