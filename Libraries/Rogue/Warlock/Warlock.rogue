library Warlock

nativeHeader @|#include "WarlockInterface.h"

$include Warlock/BitmapIO
$include Warlock/Box
$include Warlock/Macros
$include Warlock/Display
$include Warlock/DisplayState
$include Warlock/Drawable2D
$include Warlock/RendererBatch
$include Warlock/Framework
$include Warlock/IDGenerator
$include Warlock/Image
$include Warlock/Line
$include Warlock/MeshBuilder
$include Warlock/ProjectionMode
$include Warlock/Renderer
$include Warlock/Scene
$include Warlock/SceneState
$include Warlock/Shader
$include Warlock/State
$include Warlock/Texture
$include Warlock/Triangle
$include Warlock/Vertex
$include Warlock/View
$include Warlock/ViewState
$include Warlock/Window

uses Control/State
uses Entity
uses Geometry [export]
uses Graphics [export]
uses Math/Matrix
uses UI

State = State() subclass
  PROPERTIES
    angle   : Degrees
    image   : Image
    child   : Image

  METHODS
    method on_start
      if local file = Warlock.find_asset( "Assets/Images/Hannah-and-Burf.jpg" )
        #if local file = Warlock.find_asset( "Assets/Images/123.png" )
        local texture = Texture( Texture(file) )
        image = Image( texture )
        child = Image(XY(256,256),Color.YELLOW).[position=XY(128,128)]
        child.add( Image(texture).[size=XY(120,120), position=XY(128,128)] )
        image.add( child )
      endIf

    method on_draw
      Display.projection_mode = ProjectionMode2DX
      Display.perspective_center = XY(0.5,0.25)

      image.anchor = Anchor.CENTER
      image.internal_size = XY(512)
      image.scale_to_fill(Display.bounds)
      image.rotation = 0
      #image.draw( Display.center )

      #Display.bounds.fill( Color.BLACK.with_opacity(0.5) )
      #image.scale_to_fit(Display.bounds)
      image.size = XY(256)
      image.rotation = angle
      image.draw( Display.center )
      angle += 1
      child.rotation += Degrees(1.5)

      #Display.push_object_transform( Matrix.translate(Display.size*XY(0.5,0.25)) * Matrix.rotate_y(Degrees(45)) )
      #Display.push_object_transform( Matrix.rotate_y(Degrees(45)) * Matrix.translate(Display.size/2) )
      #Box(-128,-128,256,256).fill( texture )
      #Display.push_object_transform( Matrix.translate(XY(-128,-128)) )
      #Box(0,0,256,256).fill( Color(0x55FFFFFF) )

      #{
      local len = Display.size.min * 0.45
      local triangle = Triangle(
        XY( len, Degrees(30) ),
        XY( len, Degrees(150) ),
        XY( len, Degrees(270) )
      ).rotated( angle ) + Display.center
      }#

      #triangle.fill( Color.CYAN )
      #triangle.draw( Color.WHITE )
      #triangle.fill( texture )


      #{
      Renderer.draw_lines
      Renderer.data.add Vertex( XYZ(-1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1,-1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1, 1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ(-1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add Vertex( XYZ( 1,-1, 1), Color(0xFFFFFFFF) )
      Renderer.data.add( 0, 1 )
      Renderer.data.add( 1, 3 )
      Renderer.data.add( 3, 2 )
      Renderer.data.add( 2, 0 )

      Renderer.data.add( 4, 5 )
      Renderer.data.add( 5, 7 )
      Renderer.data.add( 7, 6 )
      Renderer.data.add( 6, 4 )

      Renderer.data.add( 0, 4 )
      Renderer.data.add( 1, 5 )
      Renderer.data.add( 2, 6 )
      Renderer.data.add( 3, 7 )
      }#

      #{
      Renderer.draw_triangles
      Renderer.data.add( 0, 1, 2 )
      Renderer.data.add( 1, 3, 2 )
      Renderer.data.add( 4, 6, 5 )
      Renderer.data.add( 5, 6, 7 )
      Renderer.data.add( 0, 2, 4 )
      Renderer.data.add( 4, 2, 6 )
      Renderer.data.add( 1, 5, 3 )
      Renderer.data.add( 5, 7, 3 )
      Renderer.data.add( 0, 4, 1 )
      Renderer.data.add( 4, 5, 1 )
      Renderer.data.add( 2, 3, 6 )
      Renderer.data.add( 6, 3, 7 )
      }#

    method on_update


endSubclass

class Warlock [essential singleton]
  GLOBAL PROPERTIES
    mesh = MeshBuilder()

  GLOBAL METHODS
    method configure [api]
      Warlock.on_configure

    method update->Logical [api]
      local keep_running = Framework.update_events
      Warlock.render
      return keep_running

  PROPERTIES
    configured            : Logical
    windows               = Window[]

  METHODS
    method init
      println "Initializing Warlock"
      <Display.transform_modified>.on_signal( () => Renderer.flush )

      mesh.add( Vertex(XYZ(-1, 1,-1), Color.BLACK) )
      mesh.add( Vertex(XYZ( 1, 1,-1), Color.RED ) )
      mesh.add( Vertex(XYZ(-1,-1,-1), Color.GREEN) )
      mesh.add( Vertex(XYZ( 1,-1,-1), Color.YELLOW) )
      mesh.add( Vertex(XYZ(-1, 1, 1), Color.BLUE) )
      mesh.add( Vertex(XYZ( 1, 1, 1), Color.MAGENTA) )
      mesh.add( Vertex(XYZ(-1,-1, 1), Color.CYAN) )
      mesh.add( Vertex(XYZ( 1,-1, 1), Color.WHITE) )
      mesh.add(
        [
          0, 1, 2,
          1, 3, 2,
          4, 6, 5,
          5, 6, 7,
          0, 2, 4,
          4, 2, 6,
          1, 5, 3,
          5, 7, 3,
          0, 4, 1,
          4, 5, 1,
          2, 3, 6,
          6, 3, 7
        ]
      )

    method add_window( window:Window )
      windows.add( window )

    method find_asset( name:String )->File?
      local filepath = native("WarlockInterface_find_asset($name)")->String
      if (filepath) return File( filepath )
      else          return null

      #{
    method find_image( name:String )->File?
      if local result = find_asset( name )
        return File(result)
      endIf

      if (not name.begins_with("Assets/"))
        if (name.begins_with("Images/")) name = "Assets"/name
        else                             name = "Assets/Images"/name
      endIf

      if local result = find_asset( name )
        return File(result)
      endIf

      forEach (ext in image_extensions)
        local filepath = "$.$"(name,ext)
        if local result = find_asset( filepath )
          return File(result)
        endIf
      endForEach

      return null
      }#

    method find_window( id=null:Int?, native_id=null:Int? )->Window
      if local native_id = native_id
        forEach (window in windows)
          if (window.native_id == native_id) return window
        endForEach
      endIf

      if local id = id
        forEach (window in windows)
          if (window.id == id) return window
        endForEach
      endIf

      return null

    method load_asset_bytes( filepath:String )->Byte[]
      if (filepath) return Byte[]( File(filepath) )
      else          return null

    method on_configure
      if (windows.is_empty)
        Window( "Warlock", 1280, 720 )
      endIf

    method render
      State = State.updated || State()
      State.current = State  # ensure consistent state throughout render process, even after state change
      State.current.on_render
      (forEach in windows).render
      State.current.on_end_render

endClass
