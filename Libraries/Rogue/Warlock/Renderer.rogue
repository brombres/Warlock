library Warlock

class Renderer [singleton]
  PROPERTIES
    is_initialized : Logical
    frame          : Int
    data           = MeshBuilder(6144)
    primitive_type = <triangles>
    first_vertex   : Int
    first_index    : Int
    shader         : Shader
    textures       = Texture[]
    use_mipmaps    = true

    render_queue   = RendererBatch[]

    display_id     : Int
    swap_index     : Int

  METHODS
    method init
      Framework.configure

    method activate_display_graphics_context( display:Display )
      print_error

    method activate_window_graphics_context( window:Window )
      print_error

    method clear_textures
      if (textures.is_empty) return
      flush
      textures.clear

    method configure_canvas( canvas:Canvas )
      print_error

    method configure_render_target_image( image:RenderTargetImage )
      print_error

    method configure_window( window:Window )
      print_error

    method draw( line:Line, color:Color, shader=Shader.ALPHA_COLOR, thickness=1.0:Real )
      draw( Line<<XYZ>>(line.a,line.b), color, shader, thickness )

    method draw( line:Line<<XYZ>>, color:Color, shader=Shader.ALPHA_COLOR, thickness=1.0:Real )
      if (thickness == 1.0)
        clear_textures
        draw_lines
        local i0 = data.vertices.count - first_vertex
        data.add Vertex( line.a, color )
        data.add Vertex( line.b, color )
        data.add( i0, i0+1 )
      endIf

    method draw_lines
      primitive_type = <lines>

    method draw_points
      primitive_type = <points>

    method draw_triangles
      primitive_type = <triangles>

    method fill( box:Box, color:Color, shader=Shader.ALPHA_COLOR, subdivisions=XY(0,0):XY )
      clear_textures
      draw_triangles
      if (subdivisions.sum == 0)
        local i0 = data.vertices.count - first_vertex
        local a = box.position
        local b = box.top_right
        local c = box.bottom_right
        local d = box.bottom_left
        data.add Vertex( a, color )
        data.add Vertex( b, color )
        data.add Vertex( c, color )
        data.add Vertex( d, color )
        data.add( i0, i0+1, i0+2 )
        data.add( i0, i0+2, i0+3 )
      else
        .generate_quad(
          Vertex( box.position, color ),
          Vertex( box.top_right, color ),
          Vertex( box.bottom_right, color ),
          Vertex( box.bottom_left, color ),
          subdivisions
        )
      endIf

    method fill( box:Box, tl:Color, tr:Color, br:Color, bl:Color,
        shader=Shader.ALPHA_COLOR, subdivisions=XY(0,0):XY )
      clear_textures
      draw_triangles
      if (subdivisions.sum == 0)
        local i0 = data.vertices.count - first_vertex
        local a = box.position
        local b = box.top_right
        local c = box.bottom_right
        local d = box.bottom_left
        data.add Vertex( a, tl )
        data.add Vertex( b, tr )
        data.add Vertex( c, br )
        data.add Vertex( d, bl )
        data.add( i0, i0+1, i0+2 )
        data.add( i0, i0+2, i0+3 )
      else
        .generate_quad(
          Vertex( box.position, tl ),
          Vertex( box.top_right, tr ),
          Vertex( box.bottom_right, br ),
          Vertex( box.bottom_left, bl ),
          subdivisions
        )
      endIf

    method fill( box:Box, texture:Texture, color:Color, shader=Shader.ALPHA_TEXTURE,
        subdivisions=XY(0,0):XY, &h_flip, &v_flip, &use_mipmaps )
      set_texture( texture, &=use_mipmaps )
      draw_triangles

      local uv_a = texture.uv.a
      local uv_b = texture.uv.b
      local uv_c = texture.uv.c
      local uv_d = texture.uv.d

      if (h_flip)
        swapValues( uv_a, uv_b )
        swapValues( uv_c, uv_d )
      endIf

      if (v_flip)
        swapValues( uv_a, uv_d )
        swapValues( uv_b, uv_c )
      endIf

      if (subdivisions.sum == 0)
        local i0 = data.vertices.count - first_vertex
        local a = box.position
        local b = box.top_right
        local c = box.bottom_right
        local d = box.bottom_left
        data.add Vertex( a, color, uv_a )
        data.add Vertex( b, color, uv_b )
        data.add Vertex( c, color, uv_c )
        data.add Vertex( d, color, uv_d )
        data.add( i0, i0+1, i0+2 )
        data.add( i0, i0+2, i0+3 )
      else
        .generate_quad(
          Vertex( box.position, color,     uv_a ),
          Vertex( box.top_right, color,    uv_b ),
          Vertex( box.bottom_right, color, uv_c ),
          Vertex( box.bottom_left, color,  uv_d ),
          subdivisions
        )
      endIf

    method .generate_quad( tl:Vertex, tr:Vertex, br:Vertex, bl:Vertex, subdivisions:XY )
      if (subdivisions.x > 0)
        local tc = tl.avg(tr)
        local bc = bl.avg(br)
        .generate_quad( tl, tc, bc, bl, subdivisions-XY(1,0) )
        .generate_quad( tc, tr, br, bc, subdivisions-XY(1,0) )

      elseIf (subdivisions.y > 0)
        local cl = tl.avg(bl)
        local cr = tr.avg(br)
        .generate_quad( tl, tr, cr, cl, subdivisions-XY(0,1) )
        .generate_quad( cl, cr, br, bl, subdivisions-XY(0,1) )

      else
        local i0 = data.vertices.count - first_vertex
        data.add tl
        data.add tr
        data.add br
        data.add bl
        data.add( i0, i0+1, i0+2 )
        data.add( i0, i0+2, i0+3 )

      endIf

    method fill( triangle:Triangle, color:Color, shader=Shader.ALPHA_COLOR )
      clear_textures
      draw_triangles
      local i0 = data.vertices.count - first_vertex
      data.add Vertex( triangle.a, color )
      data.add Vertex( triangle.b, color )
      data.add Vertex( triangle.c, color )
      data.add( i0, i0+1, i0+2 )

    method fill( triangle:Triangle, texture:Texture, color:Color, shader=Shader.ALPHA_TEXTURE, &use_mipmaps )
      set_texture( texture, &=use_mipmaps )
      draw_triangles
      local i0 = data.vertices.count - first_vertex
      data.add Vertex( triangle.a, color, XY(0,0) )
      data.add Vertex( triangle.b, color, XY(1,0) )
      data.add Vertex( triangle.c, color, XY(1,1) )
      data.add( i0, i0+1, i0+2 )

    method flush
      local index_count = data.indices.count
      if (index_count == first_index) return
      local vertex_count = data.vertices.count

      local batch_texture  : Texture
      local batch_textures : Texture[]

      which (textures.count)
        case 0: noAction
        case 1: batch_texture = textures[0]
        others: batch_textures = ObjectPool<<Texture[]>>.on_use.[ add(textures) ]
      endWhich

      local clip = Display.clip
      if (clip)
        local world_transform = Display.world_transform
        local scale = (Display.pixel_size / Display.size).x
        local pos  = (world_transform*clip.value.position).xy * scale
        local size = (world_transform*clip.value.size).xy * scale
        clip = Box( pos, size ).floor
      endIf

      render_queue.add(
        RendererBatch(
          display_id,
          primitive_type,
          first_vertex,
          vertex_count - first_vertex,
          first_index,
          index_count - first_index,
          Display.combined_transform,
          shader,
          batch_texture,
          batch_textures,
          clip,
          use_mipmaps
        )
      )

      first_vertex = vertex_count
      first_index  = index_count

    method on_render_begin( canvas:Canvas )
      display_id = canvas.id
      draw_triangles
      shader = Shader.ALPHA_COLOR
      clear_textures

    method on_render_begin( window:Window )
      ++swap_index
      if (swap_index > 2) swap_index = 0
      reset
      display_id = window.id

    method on_render_end( canvas:Canvas )
      flush

    method on_render_end( window:Window )
      flush
      ++frame

    method on_window_resized( window:Window )
      noAction

    method print_error
      println "No Renderer is configured. Include BGFX to use the BGFX renderer."

    method reset
      data.clear
      draw_triangles
      first_vertex = 0
      first_index = 0
      shader = Shader.ALPHA_COLOR
      clear_textures
      use_mipmaps = true

    method set_clip( clip:Box? )
      print_error

    method set_display_id( new_display_id:Int )
      if (display_id == new_display_id) return
      flush
      @display_id = new_display_id

    method set_primitive_type( new_type:GlobalID )
      if (primitive_type == new_type) return
      flush
      @primitive_type = new_type

    method set_shader( new_shader:Shader )
      if (shader is new_shader) return
      flush
      @shader = new_shader.[load]

    method set_texture( new_texture:Texture, use_mipmaps=true:Logical  )
      set_use_mipmaps( use_mipmaps )
      if (new_texture.source) new_texture .= source
      if (textures.count == 1 and textures[0] is new_texture) return
      flush
      textures.expand_to_include( 0 )
      textures[0] = new_texture

    method set_texture( stage:Int, new_texture:Texture, use_mipmaps=true:Logical )
      set_use_mipmaps( use_mipmaps )
      if (new_texture.source) new_texture .= source
      if (textures.count > stage and textures[stage] is new_texture) return
      flush
      textures.expand_to_include( stage )
      textures[stage] = new_texture

    method set_use_mipmaps( setting:Logical )
      if (use_mipmaps == setting) return
      flush
      @use_mipmaps = setting

    method uses_homogeneous_depth->Logical
      return true

endClass
