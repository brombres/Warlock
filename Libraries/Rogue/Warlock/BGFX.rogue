library Warlock

nativeHeader @|#include <bgfx/bgfx.h>
nativeHeader @|#include <bgfx/platform.h>

BGFX

class BGFX : Renderer [singleton]
  PROPERTIES
    vertex_data = BGFXVertex[][]
    index_data  = Int32[][]

    native @|bgfx::DynamicVertexBufferHandle bgfx_vertex_buffer;
    native @|bgfx::DynamicIndexBufferHandle  bgfx_index_buffer;
    native @|bgfx::UniformHandle bgfx_uniform_texColor;

  METHODS
    method init
      Renderer = this
      prior.init

    method activate_display_graphics_context( display:Display ) [override]
      native
      @|uint16_t w = static_cast<uint16_t>( $display->pixel_size.x );
       |uint16_t h = static_cast<uint16_t>( $display->pixel_size.y );
       |bgfx::setViewRect( $display->id, 0, 0, w, h );
       |bgfx::setViewMode( $display->id, bgfx::ViewMode::Sequential );
       |bgfx::touch( $display->id );

    method activate_window_graphics_context( window:Window ) [override]
      native
      @|bgfx::PlatformData pd;
       |pd.nwh = $window->native_window_handle;
       |bgfx::setPlatformData( pd );

      activate_display_graphics_context( window )

    method configure_bgfx( window:Window )
      if (is_initialized) return

      loop (3)
        vertex_data.add( BGFXVertex[](6144) )
        index_data.add( Int32[](6144/2) )
      endLoop

      native
      @|SDL_Window* window = $window->sdl_window;
       |uint16_t w = static_cast<uint16_t>( $window->pixel_size.x );
       |uint16_t h = static_cast<uint16_t>( $window->pixel_size.y );
       |
       |bgfx::Init init;
       |init.type = bgfx::RendererType::Count;
       |init.resolution.width = w;
       |init.resolution.height = h;
       |init.resolution.reset = BGFX_RESET_VSYNC;
       |
       |bgfx::PlatformData platform_data{};
       |#if defined(ROGUE_PLATFORM_APPLE)
       |  $window->native_window_handle = SDL_Metal_GetLayer( SDL_Metal_CreateView(window) );
       |#else
       |  #error Must implement Native Window Handle retrieval in BGFX.configure_bgfx() for current platform.
       |#endif
       |platform_data.nwh = $window->native_window_handle;
       |init.platformData = platform_data;
       |
      if (not native("bgfx::init(init)")->Logical)
        println "[Warlock] Failed to initialize BGFX."
        return
      endIf

      native
      @|bgfx::VertexLayout vertex_layout;
       |vertex_layout.begin()
       |  .add(bgfx::Attrib::Position,  3, bgfx::AttribType::Float )
       |  .add(bgfx::Attrib::Color0,    4, bgfx::AttribType::Uint8, true)
       |  .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float )
       |.end();
       |
       |$this->bgfx_vertex_buffer = bgfx::createDynamicVertexBuffer( 6144, vertex_layout, BGFX_BUFFER_ALLOW_RESIZE );
       |$this->bgfx_index_buffer  = bgfx::createDynamicIndexBuffer( 6144, BGFX_BUFFER_ALLOW_RESIZE );

      native @|$this->bgfx_uniform_texColor = bgfx::createUniform( "s_texColor", bgfx::UniformType::Sampler );

      Shader.ALPHA_COLOR   = Shader( "AlphaColor" )
      Shader.ALPHA_TEXTURE = Shader( "AlphaTexture" )

      is_initialized = true

    method configure_canvas( canvas:Canvas )
      local image   = canvas.image
      local texture = image.texture

      native
      @|bgfx::setViewFrameBuffer( $canvas->id, $image->bgfx_frame_buffer );
       |
       |bgfx::setViewRect(
       |  $canvas->id,
       |  0, 0,
       |  static_cast<uint16_t>($texture->size.x),
       |  static_cast<uint16_t>($texture->size.y)
       |);
       |
       |bgfx::setViewClear( $canvas->id, BGFX_CLEAR_COLOR|BGFX_CLEAR_DEPTH, 0xffffffff, 1.0f, 0 );
       |
       |bgfx::touch( $canvas->id );

    method configure_render_target_image( image:RenderTargetImage )
      local color_texture = image.color_texture
      local depth_texture = image.depth_texture

      native
      @|bgfx::TextureHandle textures[2] = { $color_texture->bgfx_texture, $depth_texture->bgfx_texture };
       |$image->bgfx_frame_buffer = bgfx::createFrameBuffer( 2, textures, false );

    method configure_window( window:Window )
      configure_bgfx( window )
      activate_window_graphics_context( window )

      native @|bgfx::touch( $window->id );

    method on_render_begin( canvas:Canvas ) [override]
      prior.on_render_begin( canvas )

      if local render_target_image = canvas.image
        native @|bgfx::setViewFrameBuffer( $canvas->id, $render_target_image->bgfx_frame_buffer );
      endIf

      activate_display_graphics_context( canvas )

    method on_render_begin( window:Window )
      prior.on_render_begin( window )
      activate_window_graphics_context( window )

    method on_render_end( canvas:Canvas ) [override]
      prior.on_render_end( canvas )
      block
        local clear_flags = 0
        native @|$clear_flags |= BGFX_CLEAR_DEPTH;
        if (canvas.should_clear_color) native @|$clear_flags |= BGFX_CLEAR_COLOR;

        local clear_color = canvas.clear_color.rgba
        native @|bgfx::setViewClear( $display_id, (uint16_t)$clear_flags, (uint32_t)$clear_color );
      endBlock

    method on_render_end( window:Window ) [override]
      prior.on_render_end( window )

      block
        local clear_flags = 0
        native @|$clear_flags |= BGFX_CLEAR_DEPTH;
        if (Display.should_clear_color) native @|$clear_flags |= BGFX_CLEAR_COLOR;

        local clear_color = Display.clear_color.rgba
        native @|bgfx::setViewClear( $display_id, (uint16_t)$clear_flags, (uint32_t)$clear_color );
      endBlock

      if (render_queue.is_empty)
        native @|bgfx::touch( $display_id );
                |bgfx::frame();
        return
      endIf

      local vertex_data = this.vertex_data[swap_index]
      local index_data = this.index_data[swap_index]
      vertex_data.reserve( data.vertices.count )
      index_data.reserve( (data.indices.count+1)/2 )

      native
      @|{
       |  WarlockVertex*      src_data = (WarlockVertex*)($data->vertices->data);
       |  WarlockBGFXVertex* dest_data = (WarlockBGFXVertex*)($vertex_data->data);
       |  for (int i=(int)$data->vertices->count; --i>=0; )
       |  {
       |    dest_data->x = (float) src_data->position.x;
       |    dest_data->y = (float) src_data->position.y;
       |    dest_data->z = (float) src_data->position.z;
       |    dest_data->u = (float) src_data->uv.x;
       |    dest_data->v = (float) src_data->uv.y;
       |
       |    // Swap red and blue while premultiplying R,G,B by A.
       |    int argb = (int)src_data->color.argb;
       |    int a = (argb >> 24) & 255;
       |    int r = (((argb >> 16) & 255) * a) / 255;
       |    int g = (((argb >> 8) & 255) * a) / 255;
       |    int b = ((argb & 255) * a) / 255;
       |    dest_data->abgr = (uint32_t)((a << 24) | (b << 16) | (g << 8) | r);
       |    ++src_data;
       |    ++dest_data;
       |  }
       |}
       |
       |bgfx::update(
       |  $this->bgfx_vertex_buffer, 0,
       |  bgfx::makeRef( $vertex_data->data, (uint32_t)($data->vertices->count * sizeof(WarlockBGFXVertex)) )
       |);
       |
       |{
       |  RogueInt*  src_data = $data->indices->as_ints;
       |  uint16_t* dest_data = ((uint16_t*)($index_data->as_ints));
       |  for (int i=(int)$data->indices->count; --i>=0; )
       |  {
       |    *(dest_data++) = (uint16_t) *(src_data++);
       |  }
       |}
       |
       |bgfx::update(
       |  $this->bgfx_index_buffer, 0,
       |  bgfx::makeRef( $index_data->data, (uint32_t)($data->indices->count * sizeof(uint16_t)) )
       |);

      local clip : Box?
      forEach (batch in render_queue)
        if (clip != batch.clip)
          clip = batch.clip
          set_clip( clip )
        endIf

        local transform = batch.transform->Matrix32
        native @|bgfx::setTransform( reinterpret_cast<float*>( &$transform ) );

        local bgfx_state_flags = 0
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_WRITE_RGB | BGFX_STATE_WRITE_A);
        native @|$bgfx_state_flags |= (RogueInt) BGFX_STATE_BLEND_FUNC(BGFX_STATE_BLEND_ONE, BGFX_STATE_BLEND_INV_SRC_ALPHA);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_WRITE_Z);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_CULL_CCW);
        #native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_DEPTH_TEST_LEQUAL);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_DEPTH_TEST_ALWAYS);
        which (batch.primitive_type)
          case <lines>:  native @|$bgfx_state_flags |= (RogueInt)BGFX_STATE_PT_LINES;
          case <points>: native @|$bgfx_state_flags |= (RogueInt)BGFX_STATE_PT_POINTS;
        endWhich

        native
        @|bgfx::setVertexBuffer( 0, $this->bgfx_vertex_buffer, (uint32_t)$batch.first_vertex, (uint32_t)$batch.vertex_count );
         |bgfx::setIndexBuffer( $this->bgfx_index_buffer, (uint32_t)$batch.first_index, (uint32_t)$batch.index_count );

        if (batch.texture)
          native @|bgfx::setTexture( 0, $this->bgfx_uniform_texColor, $batch.texture->bgfx_texture );
        elseIf (batch.textures)
          forEach (texture at i in batch.textures)
            if (texture)
              native @|bgfx::setTexture( $i, $this->bgfx_uniform_texColor, $texture->bgfx_texture );
            endIf
          endForEach
        endIf

        batch.shader.apply_uniforms
        native
        @|bgfx::setState( (uint64_t)$bgfx_state_flags );
         |bgfx::submit( $batch.display_id, $batch.shader->bgfx_program );

        if (batch.textures) ObjectPool<<Texture[]>>.on_end_use( batch.textures.[clear] )

      endForEach
      render_queue.clear

      set_clip( null )

      native @|bgfx::frame();

      data.clear
      first_index = 0
      first_vertex = 0

    method on_window_resized( window:Window ) [override]
      if (is_initialized)
        local size = window.pixel_size
        activate_window_graphics_context( window )

        native
        @|bgfx::reset( $size.x, $size.y, BGFX_RESET_VSYNC );

        render_pending_frames

        native
        @|bgfx::setViewRect(
         |  $window->id,
         |  0, 0,
         |  static_cast<uint16_t>($size.x),
         |  static_cast<uint16_t>($size.y)
         |);
         |
         |bgfx::touch( $window->id );
      endIf

    method render_pending_frames
      if (is_initialized)
        native
        @|const bgfx::Stats* stats = bgfx::getStats();
         |int n = stats->numDraw;
         |if ( !n ) n = 1;
         |for (int i=n; --i>=0; ) bgfx::frame();
      endIf

    method set_clip( clip:Box? ) [override]
      if local pixel_clip = clip
        if (pixel_clip.size.x == 0)
          pixel_clip = Box( Display.pixel_size, 1, 1 )
        endIf

        native
        @|bgfx::setScissor(
         |  (uint16_t)$pixel_clip.position.x,
         |  (uint16_t)$pixel_clip.position.y,
         |  (uint16_t)$pixel_clip.size.x,
         |  (uint16_t)$pixel_clip.size.y
         |);
      else
        native @|bgfx::setScissor();
      endIf

    method uses_homogeneous_depth->Logical [override]
      # Returns 'true' if Z device coordinates are [-1,1] (homogeneous).
      # Returns 'false' if Z device coordinates are [0,1] (normalized).
      return native( "bgfx::getCaps()->homogeneousDepth" )->Logical

endClass

class BGFXVertex( x:Real32, y:Real32, z:Real32, abgr:Int32, u:Real32, v:Real32 ) [compound]
endClass

augment Shader
  PROPERTIES
    filename  : String
    is_loaded : Logical

    native @|bgfx::ProgramHandle bgfx_program;
    native @|bgfx::UniformHandle bgfx_uniforms[8];

  METHODS
    method init
      noAction

    method init( vertex_shader:Byte[], fragment_shader:Byte[] )
      init

      native
      @|$this->bgfx_program = bgfx::createProgram(
       |  bgfx::createShader( bgfx::copy($vertex_shader->as_bytes, (uint32_t)$vertex_shader->count) ),
       |  bgfx::createShader( bgfx::copy($fragment_shader->as_bytes, (uint32_t)$fragment_shader->count) ),
       |  true  // have BGFX destroy shaders
       |);

    method init_object [append]
      native
      @|for (int i=8; --i>=0; )
       |{
       |  $this->bgfx_uniforms[i] = BGFX_INVALID_HANDLE;
       |}

    method on_cleanup
      native
      @|for (int i=8; --i>=0; )
       |{
       |  bgfx::destroy( $this->bgfx_uniforms[i] );
       |  $this->bgfx_uniforms[i] = BGFX_INVALID_HANDLE;
       |}
       |
       |bgfx::destroy( $this->bgfx_program );
       |$this->bgfx_program = BGFX_INVALID_HANDLE;

    method apply_uniforms
      local uniforms = @uniforms
      if (not uniforms or uniforms.is_empty) return

      if (uniforms.count > 8) println "Warlock Shader exceeds maximum of 8 uniforms."

      ensure_loaded

      local i = 0
      forEach (value at name in uniforms)
        if (not native("bgfx::isValid($this->bgfx_uniforms[$i])")->Logical)
          native
          @|$this->bgfx_uniforms[$i] = bgfx::createUniform( $name->data->as_utf8, bgfx::UniformType::Vec4 );
          if (not native("bgfx::isValid($this->bgfx_uniforms[$i])")->Logical)
            println "No such uniform '$' in shader '$'."(name,filename)
          endIf
        endIf

        native
        @|float data[4] = { (float)$value.x, (float)$value.y, (float)$value.z, (float)$value.w };
         |bgfx::setUniform( $this->bgfx_uniforms[$i], data );

        ++i
        if (i == 8) escapeForEach
      endForEach

    method ensure_loaded->this
      if (is_loaded) return this
      is_loaded = true

      native @|$this->bgfx_program = BGFX_INVALID_HANDLE;

      if local shaders_path = Warlock.find_asset( "Assets/Shaders" )
        local listing = File(shaders_path).listing( "*$*"(filename) )
        if (listing.count > 2)
          local min_count = 0
          min_count .= or_larger( (forEach in listing).count )
          listing.discard( $.count > min_count )
        endIf
        if (listing.count == 2)
          local fs = listing.first
          local vs = listing.last
          if (fs.contains("vs",&ignore_case)) swapValues( fs, vs )
          init( Warlock.load_asset_bytes(vs), Warlock.load_asset_bytes(fs) )
          if (not exists)
            println "[Warlock] Error loading BGFX shader: $"(filename)
          endIf
          return this
        endIf
      endIf

      println "Shader not found: " + filename
      return this

    method exists->Logical
      return native("bgfx::isValid($this->bgfx_program)")->Logical

endAugment

augment Texture
  PROPERTIES
    native @|bgfx::TextureHandle bgfx_texture;

  METHODS
    method init_object [append]
      native @|$this->bgfx_texture = BGFX_INVALID_HANDLE;

  METHODS
    method set( bitmap:Bitmap )
      local is_cloned = false
      if (not bitmap.is_power_of_2 or not bitmap.is_premultiplied_alpha)
        is_cloned = true
        bitmap = bitmap.cloned
        bitmap.expand_to_power_of_2
        bitmap.premultiply_alpha
      endIf

      size = bitmap.size  # will be power of 2
      uv = Quad( XY(0,0), XY(1,0), XY(1,1), XY(0,1) )

      bitmap.swap_red_and_blue

      local mip_w = bitmap.width
      local mip_h = bitmap.height
      local mipmap_pixel_count = 1   # final 1x1
      while (mip_w > 1 or mip_h > 1)
        mipmap_pixel_count += mip_w * mip_h
        mip_w = (mip_w/2).or_larger(1)
        mip_h = (mip_h/2).or_larger(1)
      endWhile

      local mipmap_pixels = Color[]( mipmap_pixel_count )
      mipmap_pixels.add( bitmap.pixels )
      mip_w = bitmap.width
      mip_h = bitmap.height
      if (mip_w > 1 or mip_h > 1)
        mip_w = (mip_w / 2).or_larger( 1 )
        mip_h = (mip_h / 2).or_larger( 1 )
        local mipmap : Bitmap
        if (is_cloned) mipmap = bitmap.[ resize(mip_w,mip_h) ]
        else           mipmap = bitmap.resized( mip_w, mip_h )
        while (mip_w > 1 or mip_h > 1)
          mipmap_pixels.add( mipmap.pixels )
          mip_w = (mip_w / 2).or_larger( 1 )
          mip_h = (mip_h / 2).or_larger( 1 )
          mipmap.resize( mip_w, mip_h )
        endWhile
        mipmap_pixels.add( mipmap.pixels )
      endIf

      native
      @|$this->bgfx_texture = bgfx::createTexture2D(
       |  static_cast<uint16_t>($size.x), static_cast<uint16_t>($size.y),
       |  true,
       |  1,
       |  bgfx::TextureFormat::RGBA8,
       |  BGFX_SAMPLER_UVW_CLAMP | BGFX_SAMPLER_MIN_ANISOTROPIC | BGFX_SAMPLER_MAG_ANISOTROPIC,
       |  bgfx::copy( $mipmap_pixels->as_bytes, (uint32_t) ($mipmap_pixel_count*4) )
       |);

      if (not is_cloned) bitmap.swap_red_and_blue

    method on_cleanup
      native
      @|bgfx::destroy( $this->bgfx_texture );
       |$this->bgfx_texture = BGFX_INVALID_HANDLE;

    method exists->Logical
      if (source) return source.exists
      return native( "bgfx::isValid($this->bgfx_texture)" )->Logical

endAugment

augment RenderTargetImage
  PROPERTIES
    native @|bgfx::FrameBufferHandle bgfx_frame_buffer;

  METHODS
    method init_object [append]
      native @|$this->bgfx_frame_buffer = BGFX_INVALID_HANDLE;

    method on_cleanup
      native
      @|bgfx::destroy( $this->bgfx_frame_buffer );
       |$this->bgfx_frame_buffer = BGFX_INVALID_HANDLE;

    method exists->Logical
      if (not prior.exists) return false
      return native( "bgfx::isValid($this->bgfx_frame_buffer)" )->Logical

endAugment

augment RenderTargetTexture
  METHODS
    method init( size:XY, type:GlobalID )->RenderTargetTexture
      # Type should be RenderTargetTexture.COLOR or RenderTargetTexture.DEPTH.
      local w = size.x->Int.to_power_of_2  # should be power of 2 already
      local h = size.y->Int.to_power_of_2
      this.size = XY( w, h )
      uv = Quad( XY(0,0), XY(1,0), XY(1,1), XY(0,1) )

      native @|bgfx::TextureFormat::Enum format;
      which (type)
        case <COLOR>: native @|format = bgfx::TextureFormat::RGBA8;
        case <DEPTH>: native @|format = bgfx::TextureFormat::D24S8;
        others
          println "Unsupported RenderTargetTexture type: $."(type)
          native @|format = bgfx::TextureFormat::RGBA8;
      endWhich

      native
      @|$this->bgfx_texture = bgfx::createTexture2D(
       |  static_cast<uint16_t>($w), static_cast<uint16_t>($h),
       |  false,  // no mip-maps
       |  1,
       |  format,
       |  BGFX_TEXTURE_RT |
       |    BGFX_SAMPLER_UVW_CLAMP | BGFX_SAMPLER_MIN_ANISOTROPIC | BGFX_SAMPLER_MAG_ANISOTROPIC
       |);

endAugment


augment Display
  METHODS
endAugment


augment Window
  METHODS
endAugment

