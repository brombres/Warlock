library Warlock

nativeHeader @|#include <bgfx/bgfx.h>
nativeHeader @|#include <bgfx/platform.h>

BGFX

class BGFX : Renderer [singleton]
  PROPERTIES
    vertex_data = BGFXVertex[][]
    index_data  = Int32[][]

    native @|bgfx::DynamicVertexBufferHandle bgfx_vertex_buffer;
    native @|bgfx::DynamicIndexBufferHandle  bgfx_index_buffer;
    native @|bgfx::UniformHandle bgfx_uniform_texColor;

  METHODS
    method init
      Renderer = this
      prior.init

    method activate_graphics_context( window:Window )
      native
      @|bgfx::PlatformData pd;
       |pd.nwh = $window->native_window_handle;
       |bgfx::setPlatformData( pd );

    method configure_bgfx( window:Window )
      if (is_initialized) return

      loop (3)
        vertex_data.add( BGFXVertex[](6144) )
        index_data.add( Int32[](6144/2) )
      endLoop

      native
      @|SDL_Window* window = $window->sdl_window;
       |uint16_t w = static_cast<uint16_t>( $window->size.x );
       |uint16_t h = static_cast<uint16_t>( $window->size.y );
       |
       |bgfx::Init init;
       |init.type = bgfx::RendererType::Count;
       |init.resolution.width = w;
       |init.resolution.height = h;
       |init.resolution.reset = BGFX_RESET_VSYNC;
       |
       |bgfx::PlatformData platform_data{};
       |#if defined(ROGUE_PLATFORM_APPLE)
       |  $window->native_window_handle = SDL_Metal_GetLayer( SDL_Metal_CreateView(window) );
       |#else
       |  #error Must implement Native Window Handle retrieval in BGFX.configure_bgfx() for current platform.
       |#endif
       |platform_data.nwh = $window->native_window_handle;
       |init.platformData = platform_data;
       |
      if (not native("bgfx::init(init)")->Logical)
        Global.error.println "[Warlock] Failed to initialize BGFX."
        return
      endIf

      native
      @|bgfx::VertexLayout vertex_layout;
       |vertex_layout.begin()
       |  .add(bgfx::Attrib::Position,  3, bgfx::AttribType::Float )
       |  .add(bgfx::Attrib::Color0,    4, bgfx::AttribType::Uint8, true)
       |  .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float )
       |.end();
       |
       |$this->bgfx_vertex_buffer = bgfx::createDynamicVertexBuffer( 6144, vertex_layout, BGFX_BUFFER_ALLOW_RESIZE );
       |$this->bgfx_index_buffer  = bgfx::createDynamicIndexBuffer( 6144, BGFX_BUFFER_ALLOW_RESIZE );

      native @|$this->bgfx_uniform_texColor = bgfx::createUniform( "s_texColor", bgfx::UniformType::Sampler );

      Shader.ALPHA_COLOR   = Shader( "AlphaColor" )
      Shader.ALPHA_TEXTURE = Shader( "AlphaTexture" )

      is_initialized = true

    method configure_window( window:Window )
      configure_bgfx( window )
      activate_graphics_context( window )

      native
      @|uint16_t w = static_cast<uint16_t>( $window->size.x );
       |uint16_t h = static_cast<uint16_t>( $window->size.y );
       |bgfx::setViewRect( $window->id, 0, 0, w, h );
       |bgfx::touch( $window->id );
       |bgfx::setViewClear( $window->id, BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH, 0x0000ffff );

    method on_end_render( window:Window ) [override]
      prior.on_end_render( window )

      if (render_queue.is_empty)
        native @|bgfx::frame();
        return
      endIf

      local vertex_data = this.vertex_data[swap_index]
      local index_data = this.index_data[swap_index]
      vertex_data.reserve( data.vertices.count )
      index_data.reserve( (data.indices.count+1)/2 )

      native
      @|{
       |  WarlockVertex*      src_data = (WarlockVertex*)($data->vertices->data);
       |  WarlockBGFXVertex* dest_data = (WarlockBGFXVertex*)($vertex_data->data);
       |  for (int i=(int)$data->vertices->count; --i>=0; )
       |  {
       |    dest_data->x = (float) src_data->position.x;
       |    dest_data->y = (float) src_data->position.y;
       |    dest_data->z = (float) src_data->position.z;
       |    dest_data->u = (float) src_data->uv.x;
       |    dest_data->v = (float) src_data->uv.y;
       |    RogueInt argb = src_data->color.argb;
       |    dest_data->abgr = (uint32_t)((argb & 0xFF00FF00) | ((argb << 16) & 0xFF0000) | ((argb >> 16) & 0xFF));
       |    ++src_data;
       |    ++dest_data;
       |  }
       |}
       |
       |bgfx::update(
       |  $this->bgfx_vertex_buffer, 0,
       |  bgfx::makeRef( $vertex_data->data, (uint32_t)($data->vertices->count * sizeof(WarlockBGFXVertex)) )
       |);
       |
       |{
       |  RogueInt*  src_data = $data->indices->as_ints;
       |  uint16_t* dest_data = ((uint16_t*)($index_data->as_ints));
       |  for (int i=(int)$data->indices->count; --i>=0; )
       |  {
       |    *(dest_data++) = (uint16_t) *(src_data++);
       |  }
       |}
       |
       |bgfx::update(
       |  $this->bgfx_index_buffer, 0,
       |  bgfx::makeRef( $index_data->data, (uint32_t)($data->indices->count * sizeof(uint16_t)) )
       |);
       |

      local display_id = Display.id
      forEach (batch in render_queue)

        local projection_transform = batch.projection_transform->Matrix32
        local view_transform = batch.view_transform->Matrix32
        local object_transform = batch.object_transform->Matrix32

        native
        @|bgfx::setViewTransform(
         |  $display_id,
         |  reinterpret_cast<float*>( &$view_transform ),
         |  reinterpret_cast<float*>( &$projection_transform )
         |);
         |
         |bgfx::setTransform( reinterpret_cast<float*>( &$object_transform ) );

        local bgfx_state_flags = 0
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_WRITE_RGB | BGFX_STATE_WRITE_A | BGFX_STATE_BLEND_ALPHA);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_WRITE_Z);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_CULL_CCW);
        #native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_DEPTH_TEST_LEQUAL);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_DEPTH_TEST_ALWAYS);
        which (batch.primitive_type)
          case <lines>:  native @|$bgfx_state_flags |= (RogueInt)BGFX_STATE_PT_LINES;
          case <points>: native @|$bgfx_state_flags |= (RogueInt)BGFX_STATE_PT_POINTS;
        endWhich

        native
        @|bgfx::setVertexBuffer( 0, $this->bgfx_vertex_buffer, (uint32_t)$batch.first_vertex, (uint32_t)$batch.vertex_count );
         |bgfx::setIndexBuffer( $this->bgfx_index_buffer, (uint32_t)$batch.first_index, (uint32_t)$batch.index_count );

        if (batch.texture)
          native @|bgfx::setTexture( 0, $this->bgfx_uniform_texColor, $batch.texture->bgfx_texture );
        elseIf (batch.textures)
          forEach (texture at i in batch.textures)
            if (texture)
              native @|bgfx::setTexture( $i, $this->bgfx_uniform_texColor, $texture->bgfx_texture );
            endIf
          endForEach
        endIf

        native
        @|bgfx::setState( (uint64_t)$bgfx_state_flags );
         |bgfx::submit( $display_id, $batch.shader->bgfx_program );

        if (batch.textures) ObjectPool<<Texture[]>>.on_end_use( batch.textures.[clear] )

      endForEach
      render_queue.clear

      native @|bgfx::frame();

      data.clear
      first_index = 0
      first_vertex = 0

    method on_window_resized( window:Window ) [override]
      if (is_initialized)
        local size = window.size
        activate_graphics_context( window )

        native
        @|bgfx::reset( $size.x, $size.y, BGFX_RESET_VSYNC );

        render_pending_frames

        native
        @|bgfx::setViewRect( $window->id, 0, 0, static_cast<uint16_t>($size.x), static_cast<uint16_t>($size.y) );
         |
         |bgfx::touch( $window->id );
      endIf

    method render_pending_frames
      if (is_initialized)
        native
        @|const bgfx::Stats* stats = bgfx::getStats();
         |int n = stats->numDraw;
         |if ( !n ) n = 1;
         |for (int i=n; --i>=0; ) bgfx::frame();
      endIf

    method uses_homogeneous_depth->Logical [override]
      # Returns 'true' if Z device coordinates are [-1,1] (homogeneous).
      # Returns 'false' if Z device coordinates are [0,1] (normalized).
      return native( "bgfx::getCaps()->homogeneousDepth" )->Logical

endClass

class BGFXVertex( x:Real32, y:Real32, z:Real32, abgr:Int32, u:Real32, v:Real32 ) [compound]
endClass

augment Shader
  PROPERTIES
    native @|bgfx::ProgramHandle bgfx_program;

  METHODS
    method init( filename:String )
      native @|$this->bgfx_program = BGFX_INVALID_HANDLE;

      if local shaders_path = Warlock.find_asset( "Assets/Shaders" )
        local listing = File(shaders_path).listing( "*$*"(filename) )
        if (listing.count > 2)
          local min_count = 0
          min_count .= or_larger( (forEach in listing).count )
          listing.discard( $.count > min_count )
        endIf
        if (listing.count == 2)
          local fs = listing.first
          local vs = listing.last
          if (fs.contains("vs",&ignore_case)) swapValues( fs, vs )
          init( Warlock.load_asset_bytes(vs), Warlock.load_asset_bytes(fs) )
          if (not exists)
            Global.error.println "[Warlock] Error loading BGFX shader: $"(filename)
          endIf
          return
        endIf
      endIf

      println "Shader not found: " + filename

    method init( vertex_shader:Byte[], fragment_shader:Byte[] )
      native
      @|$this->bgfx_program = bgfx::createProgram(
       |  bgfx::createShader( bgfx::copy($vertex_shader->as_bytes, (uint32_t)$vertex_shader->count) ),
       |  bgfx::createShader( bgfx::copy($fragment_shader->as_bytes, (uint32_t)$fragment_shader->count) ),
       |  true  // have BGFX destroy shaders
       |);

    method exists->Logical
      return native("bgfx::isValid($this->bgfx_program)")->Logical

endAugment

augment Texture
  PROPERTIES
    native @|bgfx::TextureHandle bgfx_texture;

  METHODS
    method init( file:File )
      native @|$this->bgfx_texture = BGFX_INVALID_HANDLE;
      if (not file.exists) return

      init( Bitmap(file) )

    method init( bitmap:Bitmap )
      bitmap.swap_red_and_blue

      local w = bitmap.width
      local h = bitmap.height
      local mipmap_pixel_count = 1   # counts the final 1x1
      while (w > 1 or h > 1)
        mipmap_pixel_count += w * h
        w = (w/2).or_larger(1)
        h = (h/2).or_larger(1)
      endWhile

      local mipmap_pixels = Color[]( mipmap_pixel_count )
      mipmap_pixels.add( bitmap.pixels )
      w = bitmap.width
      h = bitmap.height
      if (w > 1 or h > 1)
        w = (w / 2).or_larger( 1 )
        h = (h / 2).or_larger( 1 )
        local mipmap = bitmap.resized( w, h )
        while (w > 1 or h > 1)
          mipmap_pixels.add( mipmap.pixels )
          w = (w / 2).or_larger( 1 )
          h = (h / 2).or_larger( 1 )
          mipmap.resize( w, h )
        endWhile
        mipmap_pixels.add( mipmap.pixels )
      endIf

      native
      @|$this->bgfx_texture = bgfx::createTexture2D(
       |  static_cast<uint16_t>($bitmap->width), static_cast<uint16_t>($bitmap->height),
       |  true,
       |  1,
       |  bgfx::TextureFormat::RGBA8,
       |  BGFX_SAMPLER_UVW_CLAMP | BGFX_SAMPLER_MIN_ANISOTROPIC | BGFX_SAMPLER_MAG_ANISOTROPIC,
       |  bgfx::copy( $mipmap_pixels->as_bytes, $mipmap_pixel_count*4 )
       |);

      bitmap.swap_red_and_blue

    method on_cleanup
      native
      @|bgfx::destroy( $this->bgfx_texture );
       |$this->bgfx_texture = BGFX_INVALID_HANDLE;

    method exists->Logical
      return native( "bgfx::isValid($this->bgfx_texture)" )->Logical

endAugment
