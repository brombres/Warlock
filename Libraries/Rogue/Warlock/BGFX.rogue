library Warlock

nativeHeader @|#include <bgfx/bgfx.h>
nativeHeader @|#include <bgfx/platform.h>

BGFX

class BGFX : Renderer [singleton]
  PROPERTIES
    vertex_data = BGFXVertex[]
    index_data  = Int32[]

    native @|bgfx::DynamicVertexBufferHandle bgfx_vertex_buffer;
    native @|bgfx::DynamicIndexBufferHandle  bgfx_index_buffer;

  METHODS
    method init
      Renderer = this
      prior.init

    method activate_graphics_context( window:Window )
      native
      @|bgfx::PlatformData pd;
       |pd.nwh = $window->native_window_handle;
       |bgfx::setPlatformData( pd );

    method configure_bgfx( window:Window )
      if (is_initialized) return

      vertex_data.reserve( 6144 )
      index_data.reserve( 6144/2 )

      native
      @|SDL_Window* window = $window->sdl_window;
       |uint16_t w = static_cast<uint16_t>( $window->size.x );
       |uint16_t h = static_cast<uint16_t>( $window->size.y );
       |
       |bgfx::Init init;
       |init.type = bgfx::RendererType::Count;
       |init.resolution.width = w;
       |init.resolution.height = h;
       |init.resolution.reset = BGFX_RESET_VSYNC;
       |
       |bgfx::PlatformData platform_data{};
       |#if defined(ROGUE_PLATFORM_APPLE)
       |  $window->native_window_handle = SDL_Metal_GetLayer( SDL_Metal_CreateView(window) );
       |#else
       |  #error Must implement Native Window Handle retrieval in BGFX.configure_bgfx() for current platform.
       |#endif
       |platform_data.nwh = $window->native_window_handle;
       |init.platformData = platform_data;
       |
      if (not native("bgfx::init(init)")->Logical)
        Global.error.println "[Warlock] Failed to initialize BGFX."
        return
      endIf

      native
      @|bgfx::VertexLayout vertex_layout;
       |vertex_layout.begin()
       |  .add(bgfx::Attrib::Position,  3, bgfx::AttribType::Float )
       |  .add(bgfx::Attrib::Color0,    4, bgfx::AttribType::Uint8, true)
       |  .add(bgfx::Attrib::TexCoord0, 2, bgfx::AttribType::Float )
       |.end();
       |
       |$this->bgfx_vertex_buffer = bgfx::createDynamicVertexBuffer( 6144, vertex_layout, BGFX_BUFFER_ALLOW_RESIZE );
       |$this->bgfx_index_buffer  = bgfx::createDynamicIndexBuffer( 6144, BGFX_BUFFER_ALLOW_RESIZE );

      Shader.ALPHA_COLOR = Shader( Warlock.get_vs, Warlock.get_fs )

      is_initialized = true

    method configure_window( window:Window )
      configure_bgfx( window )
      activate_graphics_context( window )

      native
      @|uint16_t w = static_cast<uint16_t>( $window->size.x );
       |uint16_t h = static_cast<uint16_t>( $window->size.y );
       |bgfx::setViewRect( $window->id, 0, 0, w, h );
       |bgfx::touch( $window->id );
       |bgfx::setViewClear( $window->id, BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH, 0x0000ffff );
       |bgfx::setViewRect( $window->id, 0, 0, w, h );

    #method on_begin_draw( window:Window ) [override]
    #  prior.on_begin_draw( window )

    method on_end_draw( window:Window ) [override]
      prior.on_end_draw( window )

      vertex_data.reserve( data.vertices.count )
      index_data.reserve( (data.indices.count+1)/2 )

      native
      @|{
       |  WarlockVertex*      src_data = (WarlockVertex*)($data->vertices->data);
       |  WarlockBGFXVertex* dest_data = (WarlockBGFXVertex*)($vertex_data->data);
       |  for (int i=(int)$data->vertices->count; --i>=0; )
       |  {
       |    dest_data->x = (float) src_data->position.x;
       |    dest_data->y = (float) src_data->position.y;
       |    dest_data->z = (float) src_data->position.z;
       |    RogueInt argb = src_data->color.argb;
       |    dest_data->abgr = (uint32_t)((argb & 0xFF00FF00) | ((argb << 16) & 0xFF0000) | ((argb >> 16) & 0xFF));
       |    ++src_data;
       |    ++dest_data;
       |  }
       |}
       |
       |bgfx::update(
       |  $this->bgfx_vertex_buffer, 0,
       |  bgfx::copy( $vertex_data->data, (uint32_t)($data->vertices->count * sizeof(WarlockBGFXVertex)) )
       |);
       |
       |{
       |  RogueInt*  src_data = $data->indices->as_ints;
       |  uint16_t* dest_data = ((uint16_t*)($index_data->as_ints));
       |  for (int i=(int)$data->indices->count; --i>=0; )
       |  {
       |    *(dest_data++) = (uint16_t) *(src_data++);
       |  }
       |}
       |
       |bgfx::update(
       |  $this->bgfx_index_buffer, 0,
       |  bgfx::copy( $index_data->data, (uint32_t)($data->indices->count * sizeof(uint16_t)) )
       |);
       |

      local display_id = Display.id
      forEach (cmd in render_queue)

        local projection_transform = cmd.projection_transform->Matrix32
        local view_transform = cmd.view_transform->Matrix32
        local object_transform = cmd.object_transform->Matrix32

        native
        @|bgfx::setViewTransform(
         |  $display_id,
         |  reinterpret_cast<float*>( &$view_transform ),
         |  reinterpret_cast<float*>( &$projection_transform )
         |);
         |
         |bgfx::setTransform( reinterpret_cast<float*>( &$object_transform ) );


        local current_shader = Shader.ALPHA_COLOR

        local bgfx_state_flags = 0
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_WRITE_RGB | BGFX_STATE_WRITE_A | BGFX_STATE_BLEND_ALPHA);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_WRITE_Z);
        native @|$bgfx_state_flags |= (RogueInt)(BGFX_STATE_DEPTH_TEST_LEQUAL);
        which (cmd.primitive_type)
          case <lines>:  native @|$bgfx_state_flags |= (RogueInt)BGFX_STATE_PT_LINES;
          case <points>: native @|$bgfx_state_flags |= (RogueInt)BGFX_STATE_PT_POINTS;
        endWhich

        native
        @|bgfx::setVertexBuffer( 0, $this->bgfx_vertex_buffer, (uint32_t)$cmd.first_vertex, (uint32_t)$cmd.vertex_count );
         |bgfx::setIndexBuffer( $this->bgfx_index_buffer, (uint32_t)$cmd.first_index, (uint32_t)$cmd.index_count );
         |bgfx::setState( (uint64_t)$bgfx_state_flags );
         |bgfx::submit( $display_id, $current_shader->program );
      endForEach
      render_queue.clear

      native @|bgfx::frame();

      data.clear
      first_index = 0
      first_vertex = 0

    method on_window_resized( window:Window ) [override]
      if (is_initialized)
        local size = window.size
        activate_graphics_context( window )

        native
        @|bgfx::reset( $size.x, $size.y, BGFX_RESET_VSYNC );

        render_pending_frames

        native
        @|bgfx::setViewRect( $window->id, 0, 0, static_cast<uint16_t>($size.x), static_cast<uint16_t>($size.y) );
         |
         |bgfx::touch( $window->id );
      endIf

    method render_pending_frames
      if (is_initialized)
        native
        @|const bgfx::Stats* stats = bgfx::getStats();
         |for (int i=stats->numDraw; --i>=0; ) bgfx::frame();
      endIf

    method uses_homogeneous_depth->Logical [override]
      # Returns 'true' if Z device coordinates are [-1,1] (homogeneous).
      # Returns 'false' if Z device coordinates are [0,1] (normalized).
      return native( "bgfx::getCaps()->homogeneousDepth" )->Logical

endClass

class BGFXVertex( x:Real32, y:Real32, z:Real32, abgr:Int32, u:Real32, v:Real32 ) [compound]
endClass

class Shader
  GLOBAL PROPERTIES
    ALPHA_COLOR : Shader

  PROPERTIES
    native @|bgfx::ProgramHandle program;

  METHODS
    method init( vertex_shader:Byte[], fragment_shader:Byte[] )
      native
      @|$this->program = bgfx::createProgram(
       |  bgfx::createShader( bgfx::copy($vertex_shader->as_bytes, (uint32_t)$vertex_shader->count) ),
       |  bgfx::createShader( bgfx::copy($fragment_shader->as_bytes, (uint32_t)$fragment_shader->count) ),
       |  true  // have BGFX destroy shaders
       |);

endClass
