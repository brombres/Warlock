library AssetCompiler

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
$define PARSER_EXISTS true

$include "Cmd.rogue"
$include "Scanner.rogue"
$include "Visitor.rogue"

class ParserCore [abstract]
  DEFINITIONS
    ip_statements = 0
    ip_statement = 1
    ip_file_attributes = 2
    ip_attribute_list = 3
    ip_target_term = 4
    ip_filepath_term_or_id = 5
    ip_attribute_value_term = 6
    ip_identifier = 7
    ip_asset_type_identifier = 8
    ip_attribute_name_identifier = 9
    ip_require_eol = 10
    ip_arg_list = 11
    ip_expression = 12
    ip_assign = 13
    ip_add_subtract = 14
    ip_add_subtract__inner = 15
    ip_multiply_divide = 16
    ip_multiply_divide__inner = 17
    ip_negate = 18
    ip_term = 19
    ip_attribute_value = 20
    ip_additional_commands = 21

  PROPERTIES
    _scanner         : Scanner
    _tokens          : Token[]
    _position        : Int
    _limit           : Int
    _cmd_stack       = Cmd[]
    _list_starts     = Int[]
    _list_tokens     = Token[]
    _next_t          : Token
    _cur_t           : Token
    _saved_positions = ParserPosition[]
    start_ip         = 0
    ip               = 0
    buffer           = String()
    output           = String()

    disable_output : Int

  METHODS
    method init
      noAction

    method init( file:File )
      ensure<<_scanner>>()
      _scanner.reset( file )
      init( _scanner )

    method init( filepath:String, content:String )
      ensure<<_scanner>>()
      _scanner.reset( filepath, content )
      init( _scanner )

    method init( _scanner )
      local tokens = _scanner.tokenize
      if (_scanner.output.count) print _scanner.output; flush
      init( tokens )

    method init( _tokens )
      _position = 0
      _limit = _tokens.count
      _cmd_stack.clear
      output.clear

    method reset
      _position = 0
      _cmd_stack.clear
      _list_starts.clear
      _list_tokens.clear
      _saved_positions.clear
      start_ip = 0
      ip = 0
      buffer.clear
      output.clear

    method reset( file:File )
      ensure<<_scanner>>()
      _scanner.reset( file )
      reset

    method reset( filepath:String, content:String )
      ensure<<_scanner>>()
      _scanner.reset( filepath, content )
      reset( _scanner )

    method reset( _scanner )
      reset
      init( _scanner )

    method has_another->Logical
      return _position < _limit

    method parse( ip=null:Int? )->Cmd
      if (_position == _limit) return null
      if (ip) start_ip = ip.value
      _list_starts.clear
      _list_tokens.clear
      _next_t = _peek
      _cur_t = _next_t
      _execute( start_ip )
      _on_output_line # flush any buffered output
      if (disable_output) return null
      if (_cmd_stack.count != 1)
        @trace _cmd_stack
        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
      endIf
      return _cmd_stack.remove_last

    method _begin_list
      _list_starts.add( _cmd_stack.count )
      _list_tokens.add( _next_t )

    method _consume( type:TokenType )->Logical
      if (_next_t.type != type) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_content( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_eols
      while (_next_t.type == TokenType.EOL)
        ++_position
        _next_t = _peek
      endWhile

    method _create_token_list( &preserve_stack )
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] createTokenList/produceTokenlist without prior savePosition." )
      endIf
      local pos = _saved_positions.remove_last
      if (not preserve_stack) _cmd_stack.discard_from( pos.cmd_stack_count )
      local i1 = pos.position
      local limit = _position
      local list = Token[]( limit - i1 )
      forEach (i in i1..<limit) list.add( _tokens[i] )
      _push( TokenList(_tokens[i1],list), 0 )

    method _describe( type:TokenType )->String
      if (type.symbol[0].is_letter) return type.symbol
      return "'$'" (type.symbol)

    method _discard_list
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] discardList without corresponding beginList." )
      endIf
      _list_starts.remove_last
      _list_tokens.remove_last

    method _discard_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to discard." )
      endIf
      _saved_positions.remove_last

    method _duplicate
      if (disable_output)
        return
      elseIf (_cmd_stack.count)
        _cmd_stack.add( _cmd_stack.last )
      else
        throw _peek.error( "[INTERNAL] Attempt to duplicate command on empty command stack." )
      endIf

    method _list_t->Token
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] createList/produceList without corresponding beginList." )
      endIf
      return _list_tokens.remove_last

    method _must_consume_content( content:String )
      if (_consume_content(content)) return
      local expected = which{ content.contains('\''):content || "'$'"(content.to_escaped_ascii) }
      local next = _describe( _peek.type )
      _throw_syntax_error( "Expected $, found $." (expected,next) )

    method _next_is( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output )
      flush
      output.clear

    method _on_t->Token
     local result = _next_t
     ++_position
     _next_t = _peek
     return result

    method _peek->Token
      if (_position < _limit) return _tokens[ _position ]
      if (_tokens.count) return _tokens.last.cloned( TokenType.EOI )
      return Token( TokenType.EOI, null, null, 0, 0 )

    method _pop->Cmd
      if (disable_output)       return null
      elseIf (_cmd_stack.count) return _cmd_stack.remove_last
      throw _peek.error( "[INTERNAL] Attempt to pop command off empty command stack." )

    method _push( cmd:Cmd )
      if (not disable_output) _cmd_stack.add( cmd )

    method _push( cmd:Cmd, node_arg_count:Int )
      if (node_arg_count) _cmd_stack.discard_from( _cmd_stack.count - node_arg_count )
      _cmd_stack.add( cmd )

    method _push_list( list:Cmd )
      local i1 = _list_starts.remove_last
      list.add( forEach in _cmd_stack from i1 )
      _cmd_stack.discard_from( i1 )
      _cmd_stack.add( list )

    method _read->Token
      local result = _next_t
      if (_position < _limit) ++_position; _next_t = _peek
      return result

    method _restore_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to restore." )
      endIf
      local pos = _saved_positions.remove_last
      _position = pos.position
      _cmd_stack.discard_from( pos.cmd_stack_count )
      _cur_t = pos.cur_t
      _next_t = _peek

    method _save_position
      _saved_positions.add( ParserPosition(_position,_cmd_stack.count,_cur_t) )

    method _node_arg( relative:Int )->Cmd
      local i = _cmd_stack.count + relative
      if (i < 0) throw _peek.error( "[INTERNAL] Not enough nodes on stack to create new Cmd." )
      return _cmd_stack[i]

    method _logical_arg( relative:Int )->Logical
      local node = _node_arg( relative )
      if (node is null) return false
      return node->Logical

    method _character_arg( relative:Int )->Character
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Character

    method _int_arg( relative:Int )->Int
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Int

    method _real_arg( relative:Int )->Real
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Real

    method _string_arg( relative:Int )->String
      local node = _node_arg( relative )
      if (node is null) return null
      return node->String

    method _string_to_Logical( st:String )->Logical
      if (st.equals("false",&ignore_case)) return false
      return true

    method _string_to_Character( st:String )->Character
      if (st.count == 0) return Character(0)
      return st[0]

    method _string_to_Int( st:String )->Int
      return st->Int

    method _string_to_Real( st:String )->Real
      return st->Real

    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
      if (message is null)
        local builder = String()
        local next = _describe( _peek.type )
        if (expected)
          builder.print "Expected $, found $." (_describe(expected.value),next)
        else
          builder.print "Unexpected $." (next)
        endIf
        message = builder
      endIf

      throw _peek.error( message )

    method _execute( ip:Int )
      which (ip)
        case ip_statements: r_statements
        case ip_statement: r_statement
        case ip_file_attributes: r_file_attributes
        case ip_attribute_list: r_attribute_list
        case ip_target_term: r_target_term
        case ip_filepath_term_or_id: r_filepath_term_or_id
        case ip_attribute_value_term: r_attribute_value_term
        case ip_identifier: r_identifier
        case ip_asset_type_identifier: r_asset_type_identifier
        case ip_attribute_name_identifier: r_attribute_name_identifier
        case ip_require_eol: r_require_eol
        case ip_arg_list: r_arg_list
        case ip_expression: r_expression
        case ip_assign: r_assign
        case ip_add_subtract: r_add_subtract
        case ip_add_subtract__inner: r_add_subtract__inner
        case ip_multiply_divide: r_multiply_divide
        case ip_multiply_divide__inner: r_multiply_divide__inner
        case ip_negate: r_negate
        case ip_term: r_term
        case ip_attribute_value: r_attribute_value
        case ip_additional_commands: r_additional_commands
        others
          return
      endWhich

    method r_statements->Int
      local _previous_cur_t = _cur_t
      _begin_list
      while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
        if (_next_t.type == TokenType.EOL)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( EmptyLine(_cur_t), 0 )
          endTemporarily
        else
          r_statement
          r_require_eol
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return 0

    method r_statement->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_BRACKET)
        temporarily _cur_t = _on_t
          r_target_term
          if (not _consume(TokenType.SYMBOL_CLOSE_BRACKET)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_BRACKET )
          if (not disable_output) _push( SetTarget(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FOLDER)
        temporarily _cur_t = _on_t
          r_filepath_term_or_id
          if (not disable_output) _push( SetFolder(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_AT)
        temporarily _cur_t = _on_t
          r_file_attributes
          if (not disable_output) _push( ExistingAsset(_cur_t,_string_arg(-3),_string_arg(-2),_node_arg(-1)->(as AttributeList)), 3 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.COMMENT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Comment(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return 0

    method r_file_attributes->Int
      local _previous_cur_t = _cur_t
      r_filepath_term_or_id
      r_asset_type_identifier
      r_attribute_list
      _cur_t = _previous_cur_t
      return 0

    method r_attribute_list->Int
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.IDENTIFIER))
        r_attribute_name_identifier
        if (_consume(TokenType.SYMBOL_COLON))
          r_attribute_value_term
        else
          if (not disable_output) _push( null, 0 )
        endIf
        if (not disable_output) _push( Attribute(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( AttributeList(_list_t) )
      _cur_t = _previous_cur_t
      return 0

    method r_target_term->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.TERM)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( SetTarget(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error("Target name expected (Global, Default, iOS, ...).")
      _cur_t = _previous_cur_t
      return 0

    method r_filepath_term_or_id->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.TERM)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error("Filepath expected.")
      _cur_t = _previous_cur_t
      return 0

    method r_attribute_value_term->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.TERM)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeValue(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error("Value expected.")
      _cur_t = _previous_cur_t
      return 0

    method r_identifier->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error("Identifier expected.")
      _cur_t = _previous_cur_t
      return 0

    method r_asset_type_identifier->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error("Asset type expected (image, font, sound, music, data).")
      _cur_t = _previous_cur_t
      return 0

    method r_attribute_name_identifier->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error("Attribute name expected.")
      _cur_t = _previous_cur_t
      return 0

    method r_require_eol->Int
      local _previous_cur_t = _cur_t
      if ((not _consume(TokenType.EOL)))
        _throw_syntax_error("Expected end of line.")
        _cur_t = _previous_cur_t
        return 0
      endIf
      _cur_t = _previous_cur_t
      return 0

    method r_arg_list->Int
      local _previous_cur_t = _cur_t
      _begin_list
      while ((((_position < _limit) and (not (_next_t.type == TokenType.EOL))) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
        r_expression
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      _cur_t = _previous_cur_t
      return 0

    method r_expression->Int
      local _previous_cur_t = _cur_t
      r_assign
      _cur_t = _previous_cur_t
      return 0

    method r_assign->Int
      local _previous_cur_t = _cur_t
      r_add_subtract
      if (_next_t.type == TokenType.SYMBOL_EQUALS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_assign
          if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _cur_t = _previous_cur_t
      return 0

    method r_add_subtract->Int
      local _previous_cur_t = _cur_t
      r_multiply_divide
      r_add_subtract__inner
      _cur_t = _previous_cur_t
      return 0

    method r_add_subtract__inner->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_PLUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_multiply_divide
          if (not disable_output) _push( Add(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_add_subtract__inner
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_multiply_divide
          if (not disable_output) _push( Subtract(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_add_subtract__inner
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _cur_t = _previous_cur_t
      return 0

    method r_multiply_divide->Int
      local _previous_cur_t = _cur_t
      r_negate
      r_multiply_divide__inner
      _cur_t = _previous_cur_t
      return 0

    method r_multiply_divide__inner->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_ASTERISK)
        temporarily _cur_t = _on_t
          _consume_eols
          r_negate
          if (not disable_output) _push( Multiply(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_multiply_divide__inner
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SLASH)
        temporarily _cur_t = _on_t
          _consume_eols
          r_negate
          if (not disable_output) _push( Divide(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_multiply_divide__inner
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _cur_t = _previous_cur_t
      return 0

    method r_negate->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_negate
          if (not disable_output) _push( Negate(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      r_term
      _cur_t = _previous_cur_t
      return 0

    method r_term->Int
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _on_t
          r_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Text(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.NUMBER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Number(_cur_t,_string_to_Real(_cur_t.content)), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return 0
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return 0

    method r_attribute_value->Int
      local _previous_cur_t = _cur_t
      r_expression
      _cur_t = _previous_cur_t
      return 0

    method r_additional_commands->Int
      local _previous_cur_t = _cur_t
      if (not disable_output) _push( Asset(_cur_t,_string_arg(-3),_string_arg(-2),_node_arg(-1)->(as AttributeList)), 3 )
      _cur_t = _previous_cur_t
      return 0

endClass

class ParserPosition( position:Int, cmd_stack_count:Int, cur_t:Token ) [compound];
