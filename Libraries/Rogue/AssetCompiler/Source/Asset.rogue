library AssetCompiler

class Asset
  DEFINITIONS
    ASCII_CHARACTERS = @| !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~

  # "  <- Fix string highlighting bug

  PROPERTIES
    filepath            : String
    rule                : AssetRule

    is_modified         : Logical
    is_invalid          : Logical
    is_standalone       : Logical

    group               : AssetGroup
    info                : Variant
    placement_info      : Variant

    type                = <Unknown>
    bitmap              : Bitmap
    placements          = Placement[]
    image_size          : XY
    image_split         = XY(1,1)
    image_mipmaps       : Logical
    image_patch_count   : Int

    font_characters     : String
    font_info           : Variant
    font_height         : Int
    font_width          : Int  # -1 for variable, > 0 = fixed

  METHODS
    method init( filepath, rule )
      is_standalone = rule?.find_attribute( "standalone" )?
      if (is_standalone) group = AssetGroup()

    method bitmap->Bitmap
      if (@bitmap) return @bitmap

      bitmap = Bitmap( File(filepath) )
      if (@bitmap.error)
        is_invalid = true
        throw rule.t.error( "Error loading image '$'. File is corrupt or invalid."(filepath) )
      endIf

      return @bitmap

    method collect_properties( info )
      local file = File(filepath)
      if (not file.exists)
        throw rule.t.error( "File not found: " + filepath )
      elseIf (file.is_folder)
        throw rule.t.error( "Asset must be a file, not a folder." )
      endIf

      if (rule.contains_attribute("image"))
        type = <Image>

        contingent
          necessary (not is_modified)
          necessary (info.contains("image_size"))
          necessary (info.contains("image_split"))
          necessary (info.contains("image_mipmaps"))
          necessary (info.contains("image_patch_count"))
          image_size = XY( info//image_size )
          image_split = XY( info//image_split )
          image_mipmaps = info//image_mipmaps->Logical
          image_patch_count = info//image_patch_count->Int
        unsatisfied
          is_modified = true
          info//image_size = bitmap.size
          image_size = bitmap.size
          image_mipmaps = true
          image_patch_count = 0

          if local split_attribute = rule.find_attribute( "split" )
            .require_value(
              split_attribute,
              "COLUMNSxROWS expected, e.g. '4x2'."
            )
            local parts = split_attribute.value.value.split( 'x' )
            if (parts.count != 2)
              throw rule.t.error( "ROWSxCOLUMNS required after 'split', e.g. 'split:4x2'." )
            endIf
            image_split = XY( parts[0]->Int, parts[1]->Int )
          endIf

          info//image_split = image_split

          block
            if local mipmaps_attribute = rule.find_attribute( "mipmaps" )
              image_mipmaps = true

              local setting = mipmaps_attribute.value?.value
              if (setting)
                if (setting == "true" or setting == "false")
                  image_mipmaps = setting->Logical
                else
                  throw rule.t.error( "Expected 'mipmaps:true' or 'mipmaps:false' (default)." )
                endIf
              endIf
            endIf

            info//image_mipmaps = image_mipmaps
          endBlock

          block
            if local patch_attribute = rule.find_attribute( "patch" )
              image_patch_count = 9

              local setting = patch_attribute.value?.value
              if (setting)
                image_patch_count = setting->Int
                if (image_patch_count < 8 or image_patch_count > 9)
                  throw rule.t.error( "Expected 'patch:8', 'patch:9', or 'patch' (implies 'patch:9')." )
                endIf
              endIf
            endIf

            info//image_patch_count = image_patch_count
          endBlock

        endContingent

      elseIf (rule.contains_attribute("font"))
        type = <Font>
        contingent
          necessary (not is_modified)
          necessary (info.contains("image_size"))
          necessary (info.contains("font_characters"))
          necessary (info.contains("font_height"))
          necessary (info.contains("font_width"))
          necessary (info.contains("font_info"))
          image_size = XY( info//image_size )
          font_characters = info//font_characters
          font_height = info//font_height
          font_width  = info//font_width
          font_info   = info//font_info

        unsatisfied
          is_modified = true

          info//image_size = bitmap.size
          image_size = bitmap.size

          font_characters = parse_characters

          if local width_attribute = rule.find_attribute( "width" )
            .require_value(
              width_attribute,
              "Expected 'width:fixed', 'width:variable', or 'width:<pixels>', e.g. 'width:9'."
            )

            if (width_attribute.value.value == "variable")
              font_width = -1
            elseIf (width_attribute.value.value == "fixed")
              .infer_font_width
            else
              font_width = width_attribute.value.cmd->Int
            endIf
          else
            .infer_font_width
          endIf

          if local height_attribute = rule.find_attribute( "height" )
            .require_value(
              height_attribute,
              "Pixel height expected, e.g. 'height:17'."
            )
            font_height = height_attribute.value.cmd->Int
          else
            is_modified = true
            font_height = bitmap.height
            if (font_width == -1) --font_height
          endIf

          local info_file = File(filepath).with_extension( ".font.json" )
          if (info_file.exists)
            font_info = JSON.load( info_file )
            info//font_info = font_info
          endIf

          info//font_characters = font_characters
          info//font_width  = font_width
          info//font_height = font_height

        endContingent

      elseIf (rule.contains_attribute("font_info"))
        type = <FontInfo>
      elseIf (rule.contains_attribute("sound"))
        type = <Sound>
      elseIf (rule.contains_attribute("music"))
        type = <Music>
      elseIf (rule.contains_attribute("binary"))
        type = <Binary>
      elseIf (rule.contains_attribute("json"))
        type = <JSON>
      else
        throw rule.t.error( "No type specified in rule. Append one of [image font json sound music binary] or prefix with '-' instead of '$' to exclude."(info//rule[0]) )
      endIf

      if (info//type->GlobalID != type)
        info//type = type
        is_modified = true
      endIf

      if (not is_modified and info.contains("placements"))
        placement_info = info//placements
      endIf

    method collect_texture_filepaths( textures:IndexedSet<<String>> )
      forEach (placement in placement_info)
        textures.add( placement//atlas_filepath )
      endForEach

    method create_placements
      placement_info = undefined

      which (type)
        case <Image>
          if (image_patch_count)
            if (image_split != XY(1,1))
              throw rule.t.error( "An image cannot have both 'split' and 'patch' attributes." )
            endIf
            .create_patch_placements
          else
            local split_size = image_size / image_split
            forEach (j in 0..<image_split.y)
              forEach (i in 0..<image_split.x)
                placements.add( Placement(this, Box(XY(i,j)*split_size,split_size)) )
              endForEach
            endForEach
          endIf
        case <Font>
          if (font_width == -1) .create_variable_width_font_placements
          else                  .create_fixed_width_font_placements

          if (not font_info.is_table)
            font_info = @{
              type: "FontInfo",
              font_filepath: filepath,
              characters:    font_characters,
              offset:        placements.map<<Variant>>( (p) => 0 ),
              advance:       placements.map<<Variant>>( (p) => p.size.x->Int ),
              kerning:       {}
            }
            info//font_info = font_info
          endIf

          # If characters have been manually added to the font strip, supplement font info.
          font_info//characters = font_characters
          local n = placements.count - font_info//offset.count
          loop (n) font_info//offset.add( 0 )
          forEach (i in font_info//advance.count..<placements.count)
            font_info//advance.add( placements[i].size.x->Int )
          endForEach

          local info_file = File(filepath).with_extension( ".font.json" )
          local json = font_info->JSON( &formatted )
          if (not info_file.exists or String(info_file) != json)
            println "Creating font info  $"(info_file)
            info_file.save( json )
          endIf
      endWhich

    method image_padding->Int?
      if local padding_attribute = rule.find_attribute( "padding" )
        .require_value(
          padding_attribute,
          "Expected 'padding:<pixels-per-side>' e.g. 'padding:4'."
        )
        return padding_attribute.value.cmd->Int
      endIf

      return null

    method parse_characters->String
      local result = ASCII_CHARACTERS

      if local characters_attribute = rule.find_attribute( "characters" )
        .require_value(
          characters_attribute,
          "Expected 'characters:ascii' or e.g. 'characters:[32,'0'..'9',65..90]'."
        )
        result = characters_attribute.value.cmd.to_characters

        # Ensure characters are unique
        use characters_used = WorkList<<Logical>>
          characters_used.reserve( (result.last+1).or_larger(result.count+1) )
          forEach (ch in result)
            characters_used.expand_to_include( ch )
            if (characters_used[ch])
              local ascii : String
              if (ch >= 32 and ch != 126)
                if (ch == '\'' or ch == '"') ascii = ch
                else                         ascii = "'$'"(ch)
              else
                ascii = ch.to_escaped_ascii
              endIf
              throw rule.t.error( "Character $ (unicode $) is defined multiple times."(ascii,ch->Int) )
            else
              characters_used[ch] = true
            endIf
          endForEach
        endUse
      endIf

      return result

    method placement_info->Variant
      if (@placement_info) return @placement_info

      @placement_info = @[]

      forEach (placement in placements)
        @placement_info.add(
          @{
            atlas_filepath:placement.atlas_filepath,
            position:{x:placement.position.x->Int,y:placement.position.y->Int},
            size:{x:placement.size.x->Int,y:placement.size.y->Int}
          }
        )
      endForEach

      return @placement_info

    method .create_fixed_width_font_placements
      local w = (image_size.x / font_characters.count)->Int
      local h = image_size.y->Int
      local x = 0
      loop (font_characters.count)
        placements.add( Placement(this, Box(x,0,w,h)) )
        x += w
      endLoop

    method .create_patch_placements
      if (image_size.x == 0) return

      local x2 = image_size.x - 1
      local y2 = image_size.y - 1

      local uses_h_guides = true
      local (w1,w2,w3,uses_h_guides) = .detect_patch_widths( 0 )

      if (uses_h_guides)
        local (alt_w1,alt_w2,alt_w3,alt_uses_guides) = .detect_patch_widths( y2 )
        if (w2 != alt_w2)
          local dim1 = "# pixel".pluralized( w2 )
          local dim2 = "# pixel".pluralized( alt_w2 )
          local message = "$-patch horizontal size guides do not match: the middle piece is marked as $ on the top edge and $ on the bottom edge."(image_patch_count,dim1,dim2)
          throw rule.t.error( message )
        endIf
      endIf

      local uses_v_guides = true
      local (h1,h2,h3,uses_v_guides) = .detect_patch_heights( 0 )

      if (uses_v_guides)
        local (alt_h1,alt_h2,alt_h3,alt_uses_guides) = .detect_patch_heights( x2 )
        if (h2 != alt_h2)
          local dim1 = "# pixel".pluralized( h2 )
          local dim2 = "# pixel".pluralized( alt_h2 )
          local message = "$-patch vertical size guides do not match: the middle piece is marked as $ on the left edge and $ on the right edge."(image_patch_count,dim1,dim2)
          throw rule.t.error( message )
        endIf
      endIf

      local x1 = which{ uses_h_guides:1 || 0 }
      local y1 = which{ uses_v_guides:1 || 0 }

      placements.add( Placement(this, Box(x1,      y1,w1,h1)) )
      placements.add( Placement(this, Box(x1+w1,   y1,w2,h1)) )
      placements.add( Placement(this, Box(x1+w1+w2,y1,w3,h1)) )

      placements.add( Placement(this, Box(x1,      y1+h1,w1,h2)) )
      if (image_patch_count == 9)
        placements.add( Placement(this, Box(x1+w1,   y1+h1,w2,h2)) )
      endIf
      placements.add( Placement(this, Box(x1+w1+w2,y1+h1,w3,h2)) )

      placements.add( Placement(this, Box(x1,      y1+h1+h2,w1,h3)) )
      placements.add( Placement(this, Box(x1+w1,   y1+h1+h2,w2,h3)) )
      placements.add( Placement(this, Box(x1+w1+w2,y1+h1+h2,w3,h3)) )

    method .detect_patch_heights( x:Int )->(Int,Int,Int,Logical)
      local h1, h2, h3 : Int
      h1 = .contiguous_color_count_y( x, 1 )
      if (h1 < bitmap.height - 2)
        h2 = .contiguous_color_count_y( x, 1+h1 )
        if (h1 + h2 < bitmap.height - 2)
          h3 = .contiguous_color_count_y( x, 1+h1+h2 ) - 1
          if (h1 + h2 + h3 + 2 == bitmap.height) return (h1,h2,h3,true)
        else
          h3 = h2 - 1
          h2 = 0
          return (h1,h2,h3,true)
        endIf
      endIf

      h1 = bitmap.height / 3
      h3 = h1
      h2 = bitmap.height - (h1 + h3)
      return (h1,h2,h3,false)

    method .detect_patch_widths( y:Int )->(Int,Int,Int,Logical)
      local w1, w2, w3 : Int
      w1 = .contiguous_color_count_x( 1, y )
      if (w1 < bitmap.width - 2)
        w2 = .contiguous_color_count_x( 1+w1, y )
        if (w1 + w2 < bitmap.width - 2)
          w3 = .contiguous_color_count_x( 1+w1+w2, y ) - 1
          if (w1 + w2 + w3 + 2 == bitmap.width) return (w1,w2,w3,true)
        else
          w3 = w2 - 1
          w2 = 0
          return (w1,w2,w3,true)
        endIf
      endIf

      w1 = bitmap.width / 3
      w3 = w1
      w2 = bitmap.width - (w1 + w3)
      return (w1,w2,w3,false)

    method .contiguous_color_count_x( x1:Int, y1:Int )->Int
      local x2 = x1 + 1
      local i1 = y1 * bitmap.width + x1
      local i2 = i1 + 1
      local cur_color = bitmap.pixels[i1]

      while (x2 <= image_size.x)
        local is_finished = (x2 == image_size.x)
        if (is_finished or bitmap.pixels[i2] != cur_color)
          return (x2 - x1)
        else
          ++x2
          ++i2
        endIf
      endWhile

      return 0

    method .contiguous_color_count_y( x1:Int, y1:Int )->Int
      local w = bitmap.width
      local y2 = y1 + 1
      local j1 = y1 * w + x1
      local j2 = j1 + w
      local cur_color = bitmap.pixels[j1]

      while (y2 <= image_size.y)
        local is_finished = (y2 == image_size.y)
        if (is_finished or bitmap.pixels[j2] != cur_color)
          return (y2 - y1)
        else
          ++y2
          j2 += w
        endIf
      endWhile

      return 0

    method .create_variable_width_font_placements
      if (image_size.x == 0) return

      local h = image_size.y->Int - 1
      local x1 = 0
      while (x1 < image_size.x)
        local n = .contiguous_color_count_x( x1, 0 )
        placements.add( Placement(this, Box(x1,1,n,h)) )
        x1 += n
      endWhile

      if (placements.count != font_characters.count)
        local more_or_fewer = which{ placements.count>font_characters.count:"More" || "Fewer" }
        throw rule.t.error( "$ characters defined than specified. The variable-width font strip defines $ characters but the font rule specifies $ characters."(more_or_fewer,placements.count,font_characters.count) )
      endIf

    method timestamp->Timestamp
      local file = File( filepath )
      if (file.exists) return file.timestamp
      else             return Timestamp.now

    method to->String
      return filepath

    method update_placement_info
      info//placements = placement_info

    method write( manifest:Manifest )
      which (type)
        case <Image>
          manifest.print ''"$"''(filepath)
          manifest.print " image"
          if (image_split.product > 1)
            manifest.print " frames "
            manifest.print image_split.product->Int
          endIf
          if (not image_mipmaps)
            manifest.print " mipmaps false"
          endIf
          if (image_patch_count)
            manifest.print " patch "
            manifest.print image_patch_count
            manifest.print " frames "
            manifest.print image_patch_count
          endIf
          manifest.println
          write_placements( manifest )
        case <Font>
          manifest.print ''"$"''(filepath)
          manifest.print " font"
          manifest.print " $"(font_height)
          if (font_width == -1) manifest.print " variable"
          else                  manifest.print " $"(font_width)
          manifest.print '' "$"''(font_characters.to_escaped_unicode("\""))
          manifest.println
          if (font_info.is_table)
            manifest.println "  offset  $"(font_info//offset)
            manifest.println "  advance $"(font_info//advance)
            manifest.println "  kerning $"(font_info//kerning->JSON)
            manifest.println "  monospace $"(font_info//monospace_width->Int)
          endIf
          write_placements( manifest )
      endWhich

    method write_placements( manifest:Manifest )
      forEach (placement in placement_info)
        manifest.print "  $"(AssetCompiler.textures[placement//atlas_filepath])
        manifest.print " $ $"(placement//position//x,placement//position//y)
        manifest.print " $ $"(placement//size//x,placement//size//y)
        manifest.println
      endForEach

    method .infer_font_width
      if (bitmap.width % font_characters.count)
        throw rule.t.error( "Total size of fixed-width bitmap font ($px) is not evenly divisible by $ characters."(bitmap.width,font_characters.count) )
      endIf
      font_width = bitmap.width / font_characters.count

    method .require_value( attribute:Attribute, error_message:String )
      if (not attribute.value) throw attribute.t.error( error_message )

endClass
