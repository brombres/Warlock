library AssetCompiler

class Asset( filepath:String, rule:AssetRule )
  DEFINITIONS
    ASCII_CHARACTERS = @| !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~

    # "

  PROPERTIES
    is_modified     : Logical
    is_invalid      : Logical
    is_standalone   : Logical

    group           : AssetGroup
    info            : Variant
    placement_info  : Variant

    type            = <Unknown>
    bitmap          : Bitmap
    placements      = Placement[]
    image_size      : XY
    image_split     = XY(1,1)
    font_characters : String
    font_height     : Int
    font_width      : Int  # -1 for variable, > 0 = fixed

  METHODS
    method bitmap->Bitmap
      if (@bitmap) return @bitmap

      bitmap = Bitmap( File(filepath) )
      if (@bitmap.error)
        is_invalid = true
        throw rule.t.error( "Error loading image '$'. File is corrupt or invalid."(filepath) )
      endIf

      return @bitmap

    method collect_properties( info )
      local file = File(filepath)
      if (not file.exists)
        throw rule.t.error( "File not found: " + filepath )
      elseIf (file.is_folder)
        throw rule.t.error( "Asset must be a file, not a folder." )
      endIf

      if (rule.contains_attribute("image"))
        type = <Image>

        contingent
          necessary (not is_modified)
          necessary (info.contains("image_size"))
          necessary (info.contains("image_split"))
          image_size = XY( info//image_size )
          image_split = XY( info//image_split )
        unsatisfied
          is_modified = true
          info//image_size = bitmap.size
          image_size = bitmap.size

          if local split_attribute = rule.find_attribute( "split" )
            .require_value(
              split_attribute,
              "COLUMNSxROWS expected, e.g. '4x2'."
            )
            local parts = split_attribute.value.value.split( 'x' )
            if (parts.count != 2)
              throw rule.t.error( "ROWSxCOLUMNS required after 'split', e.g. 'split:4x2'." )
            endIf
            image_split = XY( parts[0]->Int, parts[1]->Int )
          endIf

          info//image_split = image_split
        endContingent

      elseIf (rule.contains_attribute("font"))
        type = <Font>
        contingent
          necessary (not is_modified)
          necessary (info.contains("image_size"))
          necessary (info.contains("font_characters"))
          necessary (info.contains("font_height"))
          necessary (info.contains("font_width"))
          image_size = XY( info//image_size )
          font_characters = info//font_characters
          font_height = info//font_height
          font_width  = info//font_width

        unsatisfied
          is_modified = true

          info//image_size = bitmap.size
          image_size = bitmap.size

          if local characters_attribute = rule.find_attribute( "characters" )
            .require_value(
              characters_attribute,
              "Expected 'characters:ascii' or e.g. 'characters:[32,'0'..'9',65..90]'."
            )
            font_characters = characters_attribute.value.cmd.to_characters

            # Ensure characters are unique
            use characters_used = WorkList<<Logical>>
              characters_used.reserve( (font_characters.last+1).or_larger(font_characters.count+1) )
              forEach (ch in font_characters)
                characters_used.expand_to_include( ch )
                if (characters_used[ch])
                  local ascii : String
                  if (ch >= 32 and ch != 126)
                    if (ch == '\'' or ch == '"') ascii = ch
                    else                         ascii = "'$'"(ch)
                  else
                    ascii = ch.to_escaped_ascii
                  endIf
                  throw rule.t.error( "Character $ (unicode $) is defined multiple times."(ascii,ch->Int) )
                else
                  characters_used[ch] = true
                endIf
              endForEach
            endUse

          else
            font_characters = ASCII_CHARACTERS
          endIf

          if local width_attribute = rule.find_attribute( "width" )
            .require_value(
              width_attribute,
              "Expected 'width:fixed', 'width:variable', or 'width:<pixels>', e.g. 'width:9'."
            )

            if (width_attribute.value.value == "variable")
              font_width = -1
            elseIf (width_attribute.value.value == "fixed")
              .infer_font_width
            else
              font_width = width_attribute.value.cmd->Int
            endIf
          else
            .infer_font_width
          endIf

          if local height_attribute = rule.find_attribute( "height" )
            .require_value(
              height_attribute,
              "Pixel height expected, e.g. 'height:17'."
            )
            font_height = height_attribute.value.cmd->Int
          else
            is_modified = true
            font_height = bitmap.height
            if (font_width == -1) --font_height
          endIf

          info//font_characters = font_characters
          info//font_width  = font_width
          info//font_height = font_height

        endContingent

      elseIf (rule.contains_attribute("sound"))
        type = <Sound>
      elseIf (rule.contains_attribute("music"))
        type = <Music>
      elseIf (rule.contains_attribute("binary"))
        type = <Binary>
      else
        throw rule.t.error( "No type specified in rule. Append one of [image, font, sound, music, binary] or prefix with '-' instead of '$' to exclude."(info//rule[0]) )
      endIf

      if (not is_modified and info.contains("placements"))
        placement_info = info//placements
      endIf

    method collect_texture_filepaths( textures:IndexedSet<<String>> )
      forEach (placement in placement_info)
        textures.add( placement//atlas_filepath )
      endForEach

    method create_placements
      placement_info = undefined

      which (type)
        case <Image>
          local split_size = image_size / image_split
          forEach (j in 0..<image_split.y)
            forEach (i in 0..<image_split.x)
              placements.add( Placement(this, Box(XY(i,j)*split_size,split_size)) )
            endForEach
          endForEach
        case <Font>
          if (font_width == -1) .create_variable_width_font_placements
          else                  .create_fixed_width_font_placements
      endWhich

    method placement_info->Variant
      if (@placement_info) return @placement_info

      @placement_info = @[]

      forEach (placement in placements)
        @placement_info.add(
          @{
            atlas_filepath:placement.atlas_filepath,
            position:{x:placement.position.x->Int,y:placement.position.y->Int},
            size:{x:placement.size.x->Int,y:placement.size.y->Int}
          }
        )
      endForEach

      return @placement_info

    method .create_fixed_width_font_placements
      local w = (image_size.x / font_characters.count)->Int
      local h = image_size.y->Int
      local x = 0
      loop (font_characters.count)
        placements.add( Placement(this, Box(x,0,w,h)) )
        x += w
      endLoop

    method .create_variable_width_font_placements
      if (image_size.x == 0) return

      local h = image_size.y->Int - 1
      local x1 = 0
      local x2 = 1
      local cur_color = bitmap.pixels[0]
      local n = 0
      while (x2 <= image_size.x)
        local is_finished = (x2 == image_size.x)
        if (is_finished or bitmap.pixels[x2] != cur_color)
          local w = (x2 - x1)
          placements.add( Placement(this, Box(x1,1,w,h)) )
          if (is_finished) escapeWhile
          x1 += w
          cur_color = bitmap.pixels[x1]
        else
          ++x2
        endIf
      endWhile

      if (placements.count != font_characters.count)
        local more_or_fewer = which{ placements.count>font_characters.count:"More" || "Fewer" }
        throw rule.t.error( "$ characters defined than specified. The variable-width font strip defines $ characters but the font rule specifies $ characters."(more_or_fewer,placements.count,font_characters.count) )
      endIf

    method timestamp->Timestamp
      local file = File( filepath )
      if (file.exists) return file.timestamp
      else             return Timestamp.now

    method to->String
      return filepath

    method update_placement_info
      info//placements = placement_info

    method write( manifest:Manifest )
      which (type)
        case <Image>
          manifest.print ''"$"''(filepath)
          manifest.print " image"
          if (image_split.product > 1)
            manifest.print " frames "
            manifest.print image_split.product->Int
          endIf
          manifest.println
          write_placements( manifest )
        case <Font>
          manifest.print ''"$"''(filepath)
          manifest.print " font"
          manifest.print " $"(font_height)
          if (font_width == -1) manifest.print " variable"
          else                  manifest.print " $"(font_width)
          manifest.print '' "$"''(font_characters.to_escaped_unicode("\""))
          manifest.println
          write_placements( manifest )
      endWhich

    method write_placements( manifest:Manifest )
      forEach (placement in placement_info)
        manifest.print "  $"(AssetCompiler.textures[placement//atlas_filepath])
        manifest.print " $ $"(placement//position//x,placement//position//y)
        manifest.print " $ $"(placement//size//x,placement//size//y)
        manifest.println
      endForEach

    method .infer_font_width
      if (bitmap.width % font_characters.count)
        throw rule.t.error( "Total size of fixed-width bitmap font ($px) is not evenly divisible by $ characters."(bitmap.width,font_characters.count) )
      endIf
      font_width = bitmap.width / font_characters.count

    method .require_value( attribute:Attribute, error_message:String )
      if (not attribute.value) throw attribute.t.error( error_message )

endClass
