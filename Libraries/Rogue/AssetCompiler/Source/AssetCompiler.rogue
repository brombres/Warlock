library AssetCompiler

$include "Scanner.rogue"
$include "Parser.rogue" [optional]
$include AssetGroup
$include Asset
$include AtlasPage
$include CollectAssets
$include GenerateAssetConfig
$include GroupIDManager
$include Manifest
$include ImagePacker
$include Placement

uses AssetCompiler
uses Collection/IndexedSet
uses Console/CommandLineParser
uses Geometry
uses Graphics

try
  AssetCompiler.init( System.command_line_arguments )
catch (error:CompileError)
  Console.error.println error
  System.exit 1
catch (error:Error)
  Console.error.println error
  Console.error.println error.stack_trace
  System.exit 1
endTry

class AssetCompiler [singleton]
  PROPERTIES
    platform    : String
    files       : Files
    file_lookup = [String:Logical]  # true=referenced, false=unreferenced

    targets  = Set<<String>>()
    assets   = [String:Asset]
    groups   = Set<<AssetGroup>>()
    textures = IndexedSet<<String>>()

    asset_info      : Variant
    asset_info_json = ""
    asset_info_file : File
    group_info      = @{}

    sheet_size = XY(2048,2048)

  METHODS
    method init( args:String[] )
      local platform = which{ args.count:args.first || System.os }
      init( platform )
      #command = parse_args( args )

      ## trace command
      ## has //options and possibly //args

      #if (command//options//help or command//args.count == 0)
      #  print_usage
      #  System.exit 0
      #endIf

      #if ($isDefined(PARSER_EXISTS)) parse_files
      #else                           scan_files

    method init( platform )
      load_asc( &suppress_errors )
      # Once to add new files to AssetConfig.asc.

      load_asc
      # Second time to process those new files while loading.

      local existing_textures = Set<<String>>()
      existing_textures.add( forEach in File("Build/$/Assets/Textures"(platform)).listing )

      # Apply exclusion rules
      assets.discard( $.value.rule instanceOf ExcludedAssetRule )

      block
        # Ungrouped, non-standalone assets are assigned to a common group
        local default_group : AssetGroup
        forEach (asset in assets)
          if (not asset.group)
            if (not asset.is_standalone)
              asset.group = ensure<<default_group>>
            endIf
          endIf
        endForEach
      endBlock

      # Collect groups
      # Assets can be reassigned to a group multiple times, so after that's
      # all over we figure out the final group membership.
      forEach (asset in assets)
        if local group = asset.group
          if (not groups.contains(group)) groups.add( group )
          group.add( asset )
        endIf
      endForEach

      # Use the combined asset filepath hash to match saved group info with each
      # current group.
      forEach (group in groups)
        if local info = group_info[group.hash]
          forEach (page in info//pages)
            group.filepaths.add( page )
          endForEach
        endIf
      endForEach

      (forEach in groups).configure_id

      collect_asset_info

      local all_groups = groups.cloned
      groups.remove( not $.has_modified_assets )

      create_texture_atlases

      asset_info//groups = @[]
      forEach (group in all_groups)
        asset_info//groups.add( group->Variant )
      endForEach

      textures.clear
      (forEach in assets).collect_texture_filepaths( textures )
      asset_info//textures = @[]
      asset_info//textures.add( forEach in textures )

      block build_folder = "Build/$"(platform)
        existing_textures.remove( build_folder / (forEach in textures) )
        forEach (texture in existing_textures)
          println "Removing $"(texture)
          File( texture ).delete
        endForEach
      endBlock

      # Save asset info
      block
        local json = asset_info->JSON( &formatted )
        if (json != asset_info_json)
          asset_info_file.save( json )
        endIf
      endBlock

      create_asset_manifest

    method create_asset_manifest
      local manifest = Manifest()

      manifest.println "textures $"(textures.count)
      forEach (texture_filepath in textures)
        manifest.println texture_filepath
      endForEach
      manifest.println

      forEach (asset in assets)
        asset.write( manifest )
      endForEach
      #println manifest

      local file = File( "Build/$/Assets/AssetManifest.txt"(platform) )
      if (not file.exists or String(file) != manifest)
        println "Saving $"(file)
        file.save( manifest )
      endIf

    method create_texture_atlases
      (forEach in groups).build_texture_atlas

    method load_asc( &suppress_errors )
      asset_info_file = File( "Build/$/Cache/AssetInfo.json"(platform) )
      if (asset_info_file.exists)
        asset_info_json = String( asset_info_file )
        asset_info = JSON.parse( asset_info_json )
      else
        asset_info_file.parent.create_folder
      endIf
      if (not asset_info) asset_info = @{}

      local font_system_17 = File( "Libraries/Warlock/Libraries/Framework/Assets/Font-System-17.png" )
      if (font_system_17.exists)
        font_system_17.copy_to( File("Assets/Graphics/Fonts"), &if_different )
      endIf

      files = Files( "Assets" )
      files.add( "Graphics/**" )
      files.add( "Audio/**" )
      files.add( "Data/**" )

      forEach (filepath in files)
        file_lookup[filepath] = false  # mark unreferenced to start with
      endForEach

      local statements : Cmd

      local asc = File( "Assets/AssetConfig.asc" )
      if (asc.exists)
        #forEach (t in Scanner( asc ).tokenize) println "$ $"(t.type,t)

        statements = Parser( asc ).parse
        if (statements)
          CollectAssets("Global",&=suppress_errors).visit( statements )
          if (targets.contains(platform))
            CollectAssets(platform,&=suppress_errors).visit( statements )
          else
            CollectAssets("Default",&=suppress_errors).visit( statements )
          endIf
        endIf
      endIf

      if (statements is null)
        statements = Statements( Token(TokenType.EOL,"Assets/AssetConfig.asc") )
      endIf

      local unreferenced = String[]
      forEach (entry in file_lookup.entries)
        if (not entry.value) unreferenced.add( entry.key )
      endForEach

      if (unreferenced.count)
        local new_graphics = collect_unreferenced( unreferenced, "Graphics" )
        local new_audio    = collect_unreferenced( unreferenced, "Audio" )
        local new_data     = collect_unreferenced( unreferenced, "Data" )

        print_cmd( "Update Assets/AssetConfig.asc with new asset paths" )

        local new_asc = String()
        local gen = GenerateAssetConfig( new_asc, new_graphics, new_audio, new_data )
        gen.visit( forEach in statements )
        gen.append_remaining_unreferenced

        asc.save( new_asc )
      endIf

      group_info.clear
      forEach (group in asset_info//groups)
        group_info[group//hash->Int] = group
      endForEach

    method collect_asset_info
      local lookup = asset_info.ensure_table( "assets" )

      # Remove cached assets that no longer exist.
      #forEach (info at filepath in lookup)
      #endForEach

      forEach (asset in assets)
        local info = lookup[asset.filepath]
        if (not info)
          info = @{ filepath:asset.filepath }
          lookup[asset.filepath] = info
        endIf

        local rule = asset.rule->String
        local file = File( asset.filepath )
        local timestamp = file.timestamp.value

        contingent
          necessary (info//rule == rule)
          necessary (info//timestamp == timestamp)
        unsatisfied
          asset.is_modified = true
          info//rule = rule
          info//timestamp = timestamp
          info//crc32 = file.crc32
        endContingent

        asset.collect_properties( info )
      endForEach

      assets.remove( $.is_invalid )

    method collect_unreferenced( unreferenced:String[], folder:String )->String[]
      local list = String[]

      local assets_folder = "Assets" / folder + "/"
      forEach (filepath in writer=unreferenced.rewriter)
        if (filepath.begins_with(assets_folder))
          list.add( filepath.after_first(assets_folder) )
        else
          writer.write( filepath )
        endIf
      endForEach

      return list

    method print_cmd( cmd:String )
      ConsoleStyle.set<<FG_LIGHT_GREEN>>
      print( "> " )
      println( cmd )
      ConsoleStyle.set<<FG_DEFAULT>>

endClass
