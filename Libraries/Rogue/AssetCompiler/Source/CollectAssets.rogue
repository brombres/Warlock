library AssetCompiler

class CollectAssets( target, suppress_errors=false:Logical ) : TargetVisitor
  METHODS
    method on_visit_node( cmd:AssetRule )
      if (not current_target)
        throw cmd.t.error( "A platform target ([Global], [Default], [iOS], ...) must be specified before asset rules are specified." )
      endIf
      cmd.folder = current_folder

      local filepath = (cmd.folder / cmd.filepath)
      if (File(filepath).contains_wildcards)
        local pattern = FilePattern( filepath )
        forEach (existing_asset in AssetCompiler.files)
          if (File(existing_asset).matches(pattern))
            store_asset( existing_asset, cmd )
          endIf
        endForEach
      else
        store_asset( filepath, cmd )
      endIf

    method generate_asset( filepath:String, rule:AssetRule )
      local asset = Asset( filepath, rule )
      if (rule.contains_attribute("font"))
        asset.type = <Font>
        if local source_attribute = rule.find_attribute("source")
          local font_name = source_attribute.value.cmd->String

          local height = 64
          if local height_attribute = rule.find_attribute("height")
            height = height_attribute.value.cmd->Int
          endIf

          local fixed_width = 0
          if local width_attribute = rule.find_attribute("width")
            if (width_attribute.value.cmd->String != "variable")
              fixed_width = width_attribute.value.cmd->Int
            endIf
          endIf

          local unicode = asset.parse_characters

          local is_italic = false
          if local italic_attribute = rule.find_attribute("italic")
            if (italic_attribute.value)
              is_italic = italic_attribute.value.cmd->Logical
            else
              is_italic = true
            endIf
          endIf

          local is_monospace = false
          local is_monospace_numbers = false
          if local monospace_attribute = rule.find_attribute("monospace")
            if (monospace_attribute.value)
              local value = monospace_attribute.value.cmd->String
              if (value == "numbers")
                is_monospace_numbers = true
              elseIf (value == "true")
                is_monospace = true
              elseIf (value != "false")
                throw monospace_attribute.value.t.error( "Expected 'monospace' or 'monospace:numbers'." )
              endIf
            else
              is_monospace = true
            endIf
          endIf

          local search_folders = ["Assets/Fonts"]
          local font_face = FreeTypeFace( font_name, height )
          if (font_face.error) throw source_attribute.value.cmd.t.error( font_face.error )

          local characters = font_face.render( unicode )
          if (is_italic)
            forEach (ch in characters)
              local bmp = ch.bitmap
              bmp.resize( bmp.size * 2 )
              local layers = (bmp.height + 4) / 5
              local new_bmp = Bitmap( bmp.width+(layers-1), bmp.height )
              local x = 0
              local y = (bmp.height - 5) + (bmp.height % 5) / 2
              while (y >= 0)
                bmp.blit( Box(0,y,bmp.width,5), new_bmp, XY(x,y) )
                ++x
                y -= 5
              endWhile
              new_bmp.resize( new_bmp.size/2 )
              ch.bitmap = new_bmp
            endForEach
          endIf

          local monospace_width : Int
          if (is_monospace)
            local monospacer = Monospacer()
            monospacer.add( forEach in characters )
            monospace_width = monospacer.apply
          elseIf (is_monospace_numbers)
            local monospacer = Monospacer()
            forEach (ch in characters)
              if (ch.unicode.is_number) monospacer.add( ch )
            endForEach
            monospace_width = monospacer.apply
          endIf

          local character_string = String()
          character_string.print( (forEach in characters).unicode )

          local font_info = @{
            type: "FontInfo",
            font_filepath: filepath
            characters: character_string,
            offset:     characters.map<<Variant>>( (ch) => ch.offset_x ),
            advance:    characters.map<<Variant>>( (ch) => ch.advance_x ),
            kerning:    font_face.kerning.map<<Variant>>(
            (prev,next_lookup,table) => table[prev] =
              next_lookup.map<<Variant>>(
                (next,kern,table) => table[next] = kern
              )
            )
          }

          if (is_monospace)
            font_info//monospace = "all"
            font_info//monospace_width = monospace_width
          elseIf (is_monospace_numbers)
            font_info//monospace = "numbers"
            font_info//monospace_width = monospace_width
          else
            font_info//monospace_width = 0
          endIf

          asset.font_info = font_info
          local info_file = File(filepath).with_extension( ".font.json" )
          local json = font_info->JSON( &formatted )
          if (not info_file.exists or String(info_file) != json)
            println "Creating font info  $"(info_file)
            info_file.save( json )
          endIf

          local bitmap = pack_varfont_characters( characters )
          println "Creating font strip $ [$x$]"(filepath,bitmap.width,bitmap.height)
          File(filepath).save( bitmap.to_png_bytes )

          AssetCompiler.file_lookup[filepath] = true  # file is used
          AssetCompiler.assets[filepath] = asset

        else
          throw rule.t.error( ''Expected 'source:font-name' attribute, e.g. 'source:Arial'.'' )
        endIf
      else
        throw rule.t.error( "Unsupported operation: cannot create asset of type '$'."(rule.attributes[0].name) )
      endIf

    method pack_varfont_characters( characters:FreeTypeCharacter[] )->Bitmap
      local total_w = 0
      total_w += (forEach in characters).bitmap.width.clamped_low(1)
      local bitmap = Bitmap( total_w, characters.first.bitmap.height + 1 )
      local color = Color.RED
      local x = 0
      forEach (ch in characters)
        local bmp = ch.bitmap
        local w = bmp.width.clamped_low(1)
        bitmap.fill( Box(x,0,w,1), color )
        bmp.blit( bitmap, XY(x,1) )
        if (color == Color.RED) color = Color.GREEN
        else                    color = Color.RED
        x += w
      endForEach
      return bitmap

    method store_asset( filepath:String, rule:AssetRule )
      if (not is_target_active) return

      if (AssetCompiler.file_lookup.contains(filepath))
        AssetCompiler.file_lookup[filepath] = true  # file is used
        local entry = AssetCompiler.assets.find( filepath )
        if (entry)
          # Later asset rule definitions override early definitions.
          entry.value.rule = rule
        else
          AssetCompiler.assets[filepath] = Asset( filepath, rule )
        endIf
      elseIf (rule instanceOf ExistingAssetRule)
        if (not suppress_errors)
          throw rule.t.error( "File not found '$'."(filepath) )
        endIf
      elseIf (rule instanceOf GenerateAssetRule)
        generate_asset( filepath, rule )
      endIf

    method on_visit_node( cmd:SetTarget )
      prior.on_visit_node( cmd )
      AssetCompiler.targets.add( current_target )
endClass

class Monospacer
  PROPERTIES
    monospace_width : Int
    .characters     = FreeTypeCharacter[]
    .max_advance    = Best<<Int>>( $1 > $2 )

  METHODS
    method add( ch:FreeTypeCharacter )
      .characters.add( ch )
      .max_advance.consider( ch.advance_x )

    method apply->Int
      local monospace_width = .max_advance.value
      forEach (ch in .characters)
        ch.offset_x += (monospace_width - ch.advance_x)/2
        ch.advance_x = monospace_width
      endForEach
      return monospace_width
endClass
