library AssetCompiler

class CollectAssets( target, suppress_errors=false:Logical ) : TargetVisitor
  METHODS
    method on_visit_node( cmd:AssetRule )
      if (not current_target)
        throw cmd.t.error( "A platform target ([Global], [Default], [iOS], ...) must be specified before asset rules are specified." )
      endIf
      cmd.folder = current_folder

      local filepath = (cmd.folder / cmd.filepath)
      if (File(filepath).contains_wildcards)
        local pattern = FilePattern( filepath )
        forEach (existing_asset in AssetCompiler.files)
          if (File(existing_asset).matches(pattern))
            store_asset( existing_asset, cmd )
          endIf
        endForEach
      else
        store_asset( filepath, cmd )
      endIf

    method generate_asset( filepath:String, rule:AssetRule )
      local asset = Asset( filepath, rule )
      if (rule.contains_attribute("font"))
        asset.type = <Font>
        if local source_attribute = rule.find_attribute("source")
          local font_name = source_attribute.value.cmd->String

          local height = 64
          if local height_attribute = rule.find_attribute("height")
            height = height_attribute.value.cmd->Int
          endIf

          local fixed_width = 0
          if local width_attribute = rule.find_attribute("width")
            if (width_attribute.value.cmd->String != "variable")
              fixed_width = width_attribute.value.cmd->Int
            endIf
          endIf

          local unicode = asset.parse_characters

          local is_italic = false
          if local italic_attribute = rule.find_attribute("italic")
            if (italic_attribute.value)
              is_italic = italic_attribute.value.cmd->Logical
            else
              is_italic = true
            endIf
          endIf

          local is_monospace = false
          local is_monospace_numbers = false
          if local monospace_attribute = rule.find_attribute("monospace")
            if (monospace_attribute.value)
              local value = monospace_attribute.value.cmd->String
              if (value == "numbers")
                is_monospace_numbers = true
              elseIf (value == "true")
                is_monospace = true
              elseIf (value != "false")
                throw monospace_attribute.value.t.error( "Expected 'monospace' or 'monospace:numbers'." )
              endIf
            else
              is_monospace = true
            endIf
          endIf

          local search_folders = ["Assets/Fonts"]
          local font_face = FreeTypeFace( font_name, height )
          if (font_face.error) throw source_attribute.value.cmd.t.error( font_face.error )

          local characters = font_face.render( unicode )

          if (is_italic)
            forEach (ch in characters)
              local bmp = ch.bitmap
              bmp.resize( bmp.size * 2 )
              local layers = (bmp.height + 4) / 5
              local new_bmp = Bitmap( bmp.width+(layers-1), bmp.height )
              local x = 0
              local y = (bmp.height - 5) + (bmp.height % 5) / 2
              while (y >= 0)
                bmp.blit( Box(0,y,bmp.width,5), new_bmp, XY(x,y) )
                ++x
                y -= 5
              endWhile
              new_bmp.resize( new_bmp.size/2 )
              ch.bitmap = new_bmp
            endForEach
          endIf

          if (is_monospace)
            local max_w = 0
            forEach (ch in characters)
              max_w = max_w.or_larger( ch.bitmap.width )
            endForEach
            forEach (ch in characters)
              local bmp = ch.bitmap
              if (bmp.width != max_w)
                local new_bmp = Bitmap( max_w, bmp.height )
                bmp.blit( new_bmp, XY((max_w-bmp.width)/2,0) )
                ch.bitmap = new_bmp
              endIf
            endForEach
          elseIf (is_monospace_numbers)
            local max_w = 0
            forEach (ch in characters)
              if (ch.character == ' ' or ch.character.is_number)
                max_w = max_w.or_larger( ch.bitmap.width )
              endIf
            endForEach
            forEach (ch in characters)
              local bmp = ch.bitmap
              if (bmp.width != max_w)
                if (ch.character == ' ' or ch.character.is_number)
                  local new_bmp = Bitmap( max_w, bmp.height )
                  bmp.blit( new_bmp, XY((max_w-bmp.width)/2,0) )
                  ch.bitmap = new_bmp
                endIf
              endIf
            endForEach
          endIf

          local bitmap = pack_varfont_characters( characters )
          println "Creating font strip $ [$x$]"(filepath,bitmap.width,bitmap.height)
          File(filepath).save( bitmap.to_png_bytes )

          AssetCompiler.file_lookup[filepath] = true  # file is used
          AssetCompiler.assets[filepath] = asset

        else
          throw rule.t.error( ''Expected 'source:font-name' attribute, e.g. 'source:Arial'.'' )
        endIf
      else
        throw rule.t.error( "Unsupported operation: cannot create asset of type '$'."(rule.attributes[0].name) )
      endIf

    method pack_varfont_characters( characters:FreeTypeCharacter[] )->Bitmap
      local total_w = 0
      total_w += (forEach in characters).bitmap.width.clamped_low(1)
      local bitmap = Bitmap( total_w, characters.first.bitmap.height + 1 )
      local color = Color.RED
      local x = 0
      forEach (ch in characters)
        local bmp = ch.bitmap
        local w = bmp.width.clamped_low(1)
        bitmap.fill( Box(x,0,w,1), color )
        bmp.blit( bitmap, XY(x,1) )
        if (color == Color.RED) color = Color.GREEN
        else                    color = Color.RED
        x += w
      endForEach
      return bitmap

    method store_asset( filepath:String, rule:AssetRule )
      if (not is_target_active) return

      if (AssetCompiler.file_lookup.contains(filepath))
        AssetCompiler.file_lookup[filepath] = true  # file is used
        local entry = AssetCompiler.assets.find( filepath )
        if (entry)
          # Later asset rule definitions override early definitions.
          entry.value.rule = rule
        else
          AssetCompiler.assets[filepath] = Asset( filepath, rule )
        endIf
      elseIf (rule instanceOf ExistingAssetRule)
        if (not suppress_errors)
          throw rule.t.error( "File not found '$'."(filepath) )
        endIf
      elseIf (rule instanceOf GenerateAssetRule)
        generate_asset( filepath, rule )
      endIf

    method on_visit_node( cmd:SetTarget )
      prior.on_visit_node( cmd )
      AssetCompiler.targets.add( current_target )
endClass
