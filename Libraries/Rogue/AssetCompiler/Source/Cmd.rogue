# Generated and updated by Froley. Custom changes will not be overwritten; customize as desired.
library AssetCompiler

class Cmd( t:Token )
  GLOBAL METHODS
    method to_character( st:String )->Character
      if (st is null or st.count == 0) return Character(0)
      return st[0]

  METHODS
    method init( existing:Cmd )
      t = existing.t

    method cloned->ThisType [propagated]
      return ThisType(this)

    method add( cmd:Cmd )
      throw UnsupportedOperationError()

    method clear
      throw UnsupportedOperationError()

    method count->Int
      return 0

    method description->String
      return "Cmd"

    method dispatch<<$m,$VisitorType>>( visitor:$VisitorType )  [propagated]
      visitor.$m( this )

    method dispatch<<$m,$VisitorType,$ReturnType>>( visitor:$VisitorType )->$ReturnType [propagated]
      return visitor.$m( this )

    method first->Cmd
      throw UnsupportedOperationError()

    method get( index:Int )->Cmd
      throw UnsupportedOperationError()

    method get<<$AsType>>( index:Int )->$AsType
      return get(index)->(as $AsType)

    method insert( element:Cmd, before_index=0:Int )
      throw UnsupportedOperationError()

    method last->Cmd
      throw UnsupportedOperationError()

    method remove_first->Cmd
      throw UnsupportedOperationError()

    method remove_last->Cmd
      throw UnsupportedOperationError()

    method set( index:Int, value:Cmd )
      throw UnsupportedOperationError()

    method to->Character
      return Character(this->Int)

    method to->Cmd[]
      throw UnsupportedOperationError()

    method to->Int
      return 0

    method to->Logical
      return (this->Int)?

    method to->Real
      return this->Int

    method to->String
      return description

    method to->Token[]
      throw UnsupportedOperationError()

    method to_characters->String
      throw t.error( "TODO: $.to_characters()"(type_name) )
endClass

class CmdList : Cmd
  PROPERTIES
    list = Cmd[]

  METHODS
    method init( t )
      noAction

    method init( t, element:Cmd )
      list.add( element )

    method init( t, element1:Cmd, element2:Cmd )
      list.add( element1 )
      list.add( element2 )

    method init( existing:CmdList )
      prior.init( existing )

      # Start with shallow clone
      list = existing.list.cloned

      # Turn into deep clone
      localize list
      forEach (cmd at i in list)
        if (cmd) list[i] = cmd.cloned
      endForEach

    method add( cmd:Cmd )
      @list.add( cmd )

    method clear
      @list.clear

    method count->Int
      return @list.count

    method description->String
      return "CmdList" + list_description

    method first->Cmd
      return @list.first

    method get( index:Int )->Cmd
      return @list[index]

    method insert( element:Cmd, before_index=0:Int )
      list.insert( element, before_index )

    method last->Cmd
      return @list.last

    method list_description->String
      local builder = String()
      builder.print '['
      forEach (element at index in @list)
        if (index > 0) builder.print ','
        builder.print( %element )
      endForEach
      builder.print ']'
      return builder

    method remove_first->Cmd
      return @list.remove_first

    method remove_last->Cmd
      return @list.remove_last

    method set( index:Int, value:Cmd )
      @list[index] = value

    method to->Cmd[]
      return @list

endClass

class TokenList : Cmd
  PROPERTIES
    tokens : Token[]

  METHODS
    method init( t )
      tokens = Token[]

    method init( t, tokens )

    method init( existing:TokenList )
      tokens = existing.tokens.cloned

    method description->String
      return "TokenList($)"(tokens)

    method to->Token[]
      return tokens
endClass

class Unary( t, operand:Cmd ) : Cmd
  METHODS
    method init( existing:Unary )
      prior.init( existing )
      operand = existing.operand.cloned

    method description->String
      return "Unary($)"(%operand)
endClass

class Binary( t, left:Cmd, right:Cmd ) : Cmd
  METHODS
    method init( existing:Binary )
      prior.init( existing )
      left = existing.left.cloned
      right = existing.right.cloned

    method description->String
      return "Binary($,$)"(%left,%right)
endClass

class Add : Binary
  METHODS
    method description->String
      return "Add($,$)" (%left,%right)

endClass

class Args : CmdList
  METHODS
    method description->String
      return "Args" + list_description
endClass

class Assign : Binary
  METHODS
    method description->String
      return "Assign($,$)" (%left,%right)

endClass

class Divide : Binary
  METHODS
    method description->String
      return "Divide($,$)" (%left,%right)

endClass

class LiteralString : Cmd
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method init( existing:LiteralString )
      prior.init( existing )
      value = existing.value

    method description->String
      return "LiteralString($)" (%value)

    method to->Character
      return Cmd.to_character(value)

    method to->Int:     return value
    method to->Logical: return value?
    method to->String: return value

endClass

class Multiply : Binary
  METHODS
    method description->String
      return "Multiply($,$)" (%left,%right)

endClass

class Negate : Unary
  METHODS
    method description->String
      return "Negate($)" (%operand)

endClass

class Number : Cmd
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method init( existing:Number )
      prior.init( existing )
      value = existing.value

    method description->String
      return "Number($)" (%value)

    method to->Int:    return value
    method to->Real:   return value
    method to->String: return value

    method to->Character
      return value->Int->Character

    method to_characters->String
      return value->Int->Character->String

endClass

class Print : Cmd
  PROPERTIES
    args : Cmd

  METHODS
    method init( t, args )

    method init( existing:Print )
      prior.init( existing )
      if (existing.args) args = existing.args.cloned

    method description->String
      return "Print($)" (%args)

endClass

class Println : Print
  METHODS
    method description->String
      return "Println($)" (%args)

endClass

class Statements : CmdList
  METHODS
    method description->String
      return "Statements" + list_description
endClass

class Subtract : Binary
  METHODS
    method description->String
      return "Subtract($,$)" (%left,%right)

endClass

class Identifier : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method init( existing:Identifier )
      prior.init( existing )
      name = existing.name

    method description->String
      return "Identifier($)" (%name)

    method to->Character
      return Cmd.to_character(name)


    method to->Int:     return name
    method to->Logical: return name?
    method to->String: return name

    method to_characters->String
      which (name)
        case "ascii"
          return @| !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
        # "
        case "numbers"
          return @|0123456789
        others
          throw t.error(
            "Invalid character range specifier '$'. Valid range specifiers are 'ascii' and 'numbers'."(name)
          )
      endWhich

endClass

class SetTarget : Cmd
  PROPERTIES
    name : String

  METHODS
    method init( t, name )

    method init( existing:SetTarget )
      prior.init( existing )
      name = existing.name

    method description->String
      return "SetTarget($)" (%name)

    method to->Character
      return Cmd.to_character(name)

    method to->Int:     return name
    method to->Logical: return name?
    method to->String: return name

endClass

class SetFolder : Cmd
  PROPERTIES
    path : String

  METHODS
    method init( t, path )

    method init( existing:SetFolder )
      prior.init( existing )
      path = existing.path

    method description->String
      return "SetFolder($)" (%path)

    method to->Character
      return Cmd.to_character(path)

    method to->Int:     return path
    method to->Logical: return path?
    method to->String: return path

endClass

class Attribute : Cmd
  PROPERTIES
    name  : String
    value : AttributeValue

  METHODS
    method init( t, name, value )

    method init( existing:Attribute )
      prior.init( existing )
      name = existing.name
      if (existing.value) value = existing.value.cloned

    method description->String
      return "Attribute($,$)" (%name,%value)

endClass

class AttributeList : CmdList
  METHODS
    method description->String
      return "AttributeList" + list_description

    method find( name:String )->Attribute
      forEach (attribute in this)
        if (attribute.name == name) return attribute
      endForEach
      return null

    method get( index:Int )->Attribute
      return prior.get( index )->(as Attribute)
endClass

class AttributeValue : Cmd
  GLOBAL PROPERTIES
    value_parser  = Parser()

  PROPERTIES
    value : String
    cmd   : Cmd

  METHODS
    method init( t, value )
      value_parser.reset( t, Scanner.ip_tokenize_value, &scan_limit=value.count )
      cmd = value_parser.parse( Parser.ip_attribute_value )

    method init( existing:AttributeValue )
      prior.init( existing )
      value = existing.value
      cmd   = existing.cmd

    method description->String
      return "AttributeValue($,$)" (%value,%cmd)

    method to->Character
      return Cmd.to_character(value)

    method to->Int:     return which{ cmd:cmd->Int || 0 }
    method to->Logical: return which{ cmd:cmd->Logical || false }
    method to->String:  return value

endClass

class Comment : Cmd
  PROPERTIES
    content : String

  METHODS
    method init( t, content )

    method init( existing:Comment )
      prior.init( existing )
      content = existing.content

    method description->String
      return "Comment($)" (%content)

    method to->Character
      return Cmd.to_character(content)

    method to->Int:     return content
    method to->Logical: return content?
    method to->String: return content

endClass


class EmptyLine : Cmd
  METHODS
    method description->String
      return "EmptyLine"
endClass


class AssetRule : Cmd
  PROPERTIES
    folder        : String
    filepath      : String
    attributes    : AttributeList

  METHODS
    method init( t, filepath, attributes )
      # folder is set in CollectAssets

    method init( existing:AssetRule )
      prior.init( existing )
      folder   = existing.folder
      filepath = existing.filepath
      if (existing.attributes) attributes = existing.attributes.cloned

    method contains_attribute( name:String )->Logical
      return find_attribute( name )?

    method description->String
      return "AssetRule($,$,$)" (%folder,%filepath,%attributes)

    method find_attribute( name:String )->Attribute
      return attributes.find( name )

    method to->String
      local result = String()
      result.print filepath
      forEach (attribute in attributes)
        result.print( ' ' )
        result.print( attribute.name )
        if (attribute.value)
          result.print( ':' )
          result.print( attribute.value.value )
        endIf
      endForEach
      return result

endClass

class ExistingAssetRule : AssetRule
  METHODS
    method description->String
      return "ExistingAssetRule($,$,$)" (%folder,%filepath,%attributes)

    method to->String
      return "@ " + prior.to<<String>>

endClass

class LiteralList : CmdList
  METHODS
    method description->String
      return "LiteralList" + list_description

    method to_characters->String
      local result = String()
      forEach (cmd in this)
        result.print( cmd.to_characters )
      endForEach
      return result
endClass

class RangeUpTo : Binary
  METHODS
    method description->String
      return "RangeUpTo($,$)" (%left,%right)

    method to_characters->String
      local result = String()
      result.print( forEach in left->Character..right->Character )
      return result
endClass

class ExcludedAssetRule : AssetRule
  METHODS
    method description->String
      return "ExcludedAssetRule($,$)" (%filepath,%attributes)

endClass


class Group : Cmd
  PROPERTIES
    attributes : AttributeList
    filepaths  : Cmd
    multiline  : Logical

  METHODS
    method init( t, attributes, filepaths, multiline )

    method init( existing:Group )
      prior.init( existing )
      if (existing.attributes) attributes = existing.attributes.cloned
      if (existing.filepaths) filepaths = existing.filepaths.cloned
      multiline = existing.multiline

    method description->String
      return "Group($,$,$)" (%attributes,%filepaths,%multiline)

endClass

class GenerateAssetRule : AssetRule
  METHODS
    method description->String
      return "GenerateAssetRule($,$)" (%filepath,%attributes)

endClass
