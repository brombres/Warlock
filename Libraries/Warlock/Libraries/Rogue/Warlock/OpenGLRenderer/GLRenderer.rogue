module Warlock

uses Utility/Timer

class GLRenderer : Renderer [singleton]
  NATIVE
    nativeHeader
    @|#include <SDL2/SDL.h>
     |#include <SDL2/SDL_opengles2.h>
     |#include <emscripten.h>
     |#include <emscripten/html5.h>
     |#include <GLES2/gl2.h>
     |#include <GLES2/gl2ext.h>
     |
     |static EM_BOOL on_web_display_size_changed( int event_type, const EmscriptenUiEvent *event, void *user_data );

    nativeCode
    @|static EM_BOOL on_web_display_size_changed( int event_type, const EmscriptenUiEvent *event, void *user_data )
     |{
     |  %Ns%WarlockGLRenderer__on_web_display_size_changed( %NS%ROGUE_SINGLETON(WarlockGLRenderer) );
     |  return 0;
     |}

  PROPERTIES
    native "SDL_Window *window;"
    native "SDL_GLContext gl_context;"
    native "GLuint position_buffer, color_buffer, uv_buffer;"

    main_render_target    : GLRenderTarget
    current_render_target : GLRenderTarget

    is_configured        : Logical
    display_size_changed : Logical
    time_since_display_size_changed = Timer()

  METHODS
    method init
      Renderer = this

      local initial_size : XY

      native
      @|SDL_Init( SDL_INIT_VIDEO );
       |
       |SDL_GL_SetAttribute( SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES );
       |SDL_GL_SetAttribute( SDL_GL_CONTEXT_MAJOR_VERSION, 2 );
       |SDL_GL_SetAttribute( SDL_GL_CONTEXT_MINOR_VERSION, 0 );
       |SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
       |SDL_GL_SetAttribute( SDL_GL_ACCELERATED_VISUAL, 1 );
       |
       |double w, h;
       |emscripten_get_element_css_size( "#canvas", &w, &h );
       |$initial_size.x = (RogueReal) w;
       |$initial_size.y = (RogueReal) h;
       |
       |$this->window = SDL_CreateWindow( "", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, (int)w, (int)h, SDL_WINDOW_OPENGL );
       |$this->gl_context = SDL_GL_CreateContext( $this->window );
       |
       |SDL_GL_MakeCurrent( $this->window, $this->gl_context );
       |
       |glClearColor(0,0,0,1);
       |glClear(GL_COLOR_BUFFER_BIT);

      Display.size = initial_size

      main_render_target = GLRenderTarget()
      current_render_target = main_render_target

      shaders = GLShaders()

      native
      @|#if defined(%NS%ROGUE_PLATFORM_WEB)
       |  emscripten_set_resize_callback( EMSCRIPTEN_EVENT_TARGET_WINDOW, 0, 0, on_web_display_size_changed );
       |#endif

    method apply( render_mode:RenderMode, shader:GLShader )
      if (render_mode.blend_enabled)
        local gl_src_rgb_blend = render_mode.source_rgb_blend.gl_parameter
        local gl_dest_rgb_blend = render_mode.destination_rgb_blend.gl_parameter
        local gl_src_alpha_blend = render_mode.source_alpha_blend.gl_parameter
        local gl_dest_alpha_blend = render_mode.destination_alpha_blend.gl_parameter

        native
        @|glEnable( GL_BLEND );
         |glBlendFuncSeparate( $gl_src_rgb_blend, $gl_dest_rgb_blend, $gl_src_alpha_blend, $gl_dest_alpha_blend );
      endIf

      forEach (i in 0..<textures.count.or_smaller(shader.texture_parameters.count))
        local texture = textures[ i ]
        if (texture)
          local param = shader.texture_parameters[ i ]
          native @|glActiveTexture( GL_TEXTURE0+$i );
                  |glBindTexture( GL_TEXTURE_2D, $texture->gl_id );
                  |glUniform1i( $param, $i );

          local gl_mode_h = render_mode.texture_wrap_horizontal.gl_mode
          local gl_mode_v = render_mode.texture_wrap_vertical.gl_mode
          native @|glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, $gl_mode_h );
                  |glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, $gl_mode_v );

          local gl_mode_min = render_mode.texture_min_filter.gl_mode
          local gl_mode_mag = render_mode.texture_mag_filter.gl_mode
          native @|glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, $gl_mode_min );
                  |glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, $gl_mode_mag );
        endIf
      endForEach

    method clear( color:Color ) [override]
      render
      native
      @|int gl_flags = GL_COLOR_BUFFER_BIT;
       |int c = $color.argb;
       |gl_flags |= GL_COLOR_BUFFER_BIT;
       |glClearColor( ((c>>16)&255)/255.0f, ((c>>8)&255)/255.0f, (c&255)/255.0f, ((c>>24)&255)/255.0f );
       |glClear( gl_flags );

    method log_errors( where="":String )
      local error_code : Int32
      native @|$error_code = (RogueInt32) glGetError();

      # GL_INVALID_FRAMEBUFFER_OPERATION happens when resizing the screen
      if (error_code and error_code != GLError.GL_INVALID_FRAMEBUFFER_OPERATION.value)
        log.println "[Warlock] OpenGL error $: $"(where,GLError(error_code))
      endIf

    method max_texture_size->Int32
      local result : Int32
      native @|GLint result = 0;
              |glGetIntegerv( GL_MAX_TEXTURE_SIZE, &result );
              |$result = (%Ns%RogueInt32) result;
      return result

    method on_web_display_size_changed [api]
      display_size_changed = true
      time_since_display_size_changed.restart()

    method present
      if (display_size_changed and time_since_display_size_changed.elapsed >= 0.5)
        display_size_changed = false

        local sz : XY
        native
        @|double w, h;
         |emscripten_get_element_css_size( "#canvas", &w, &h );
         |SDL_SetWindowSize( $this->window, (int)w, (int) h );
         |$sz.x = (RogueReal)w;
         |$sz.y = (RogueReal)h;

        Display.size = sz
      endIf

      present( Display.size, Display.size )

    method present( display_size:XY, viewport_size:XY ) [api]
      Display.size = display_size
      main_render_target.size = display_size
      main_render_target.viewport_size = display_size
      prior.present( display_size, viewport_size )

    method render [override]
      if (not vertex_count) return

      if (not is_configured)
        is_configured = true

        native @|glGenBuffers( 1, &$this->position_buffer );
                |glGenBuffers( 1, &$this->color_buffer );
                |glGenBuffers( 1, &$this->uv_buffer );
      endIf

      local shader = shader->(as GLShader)
      shader.activate
      if (render_mode) apply( render_mode, shader )

      native @|glViewport( 0, 0, (int)$current_render_target->viewport_size.x, (int)$current_render_target->viewport_size.y );

      which (triangle_culling_mode)
        case NONE
          native @|glDisable( GL_CULL_FACE );
        case FRONT
          native @|glEnable( GL_CULL_FACE );
                  |glCullFace( GL_FRONT );
        case BACK
          native @|glEnable( GL_CULL_FACE );
                  |glCullFace( GL_BACK );
      endWhich

      which (front_face)
        case COUNTER_CLOCKWISE: native @|glFrontFace( GL_CCW );
        others:                 native @|glFrontFace( GL_CW );
      endWhich

      # Swap red and blue while premultiplying R,G,B by A.
      local count = vertex_colors.count
      native @|{
              |  RogueInt32* src = $vertex_colors->as_int32s - 1;
              |  while (--$count >= 0)
              |  {
              |    int color = *(++src);
              |    int a = (color >> 24) & 255;
              |    int r = (((color >> 16) & 255) * a) / 255;
              |    int g = (((color >> 8) & 255) * a) / 255;
              |    int b = ((color & 255) * a) / 255;
              |    *src = (a << 24) | (b << 16) | (g << 8) | r;
              |  }
              |}

      # Configure shader
      if (shader.position_attribute >= 0)
        native @|glBindBuffer(GL_ARRAY_BUFFER, $this->position_buffer);
                |glBufferData(GL_ARRAY_BUFFER, sizeof(GL_FLOAT) * $vertex_positions->count, $vertex_positions->as_real32s, GL_STREAM_DRAW );
                |glEnableVertexAttribArray( $shader->position_attribute );
                |glVertexAttribPointer( $shader->position_attribute, 4, GL_FLOAT, GL_FALSE, 0, 0);
      endIf

      if (shader.color_attribute >= 0)
        native @|glBindBuffer(GL_ARRAY_BUFFER, $this->color_buffer);
                |glBufferData(GL_ARRAY_BUFFER, 4 * $vertex_colors->count, $vertex_colors->as_int32s, GL_STREAM_DRAW );
                |glEnableVertexAttribArray( $shader->color_attribute );
                |glVertexAttribPointer( $shader->color_attribute, 4, GL_UNSIGNED_BYTE, GL_FALSE, 0, 0);
      endIf

      if (shader.uv_attribute >= 0)
        native @|glBindBuffer(GL_ARRAY_BUFFER, $this->uv_buffer);
                |glBufferData(GL_ARRAY_BUFFER, sizeof(GL_FLOAT) * $vertex_uvs->count, $vertex_uvs->as_real32s, GL_STREAM_DRAW );
                |glEnableVertexAttribArray( $shader->uv_attribute );
                |glVertexAttribPointer( $shader->uv_attribute, 2, GL_FLOAT, GL_FALSE, 0, 0);
      endIf

      # Draw primitives
      which (primitive_type)
        case POINTS
          native @|glDrawArrays( GL_POINTS, 0, $vertex_count );

        case LINES
          native @|glDrawArrays( GL_LINES, 0, $vertex_count );

        case TRIANGLES
          native @|glDrawArrays( GL_TRIANGLES, 0, $vertex_count );

        case TRIANGLE_STRIP
          native @|glDrawArrays( GL_TRIANGLE_STRIP, 0, $vertex_count );

      endWhich

      log_errors( "rendering" )

      vertex_count = 0
      vertex_positions.clear
      vertex_uvs.clear
      vertex_colors.clear

    method set_texture( texture:Texture, bitmap:Bitmap, &preserve_bitmap )
      GLTexture.set( texture, bitmap, &=preserve_bitmap )

endClass

augment Graphics::Bitmap
  GLOBAL METHODS
    method decode_png( bytes:Byte[] )->Bitmap
      return PNGDecoder().decode( bytes )
endAugment
