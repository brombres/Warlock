module Warlock

class GLShaders : Shaders
  METHODS
    method init
      color = GLColorShader()
      texture = GLTextureShader()
endClass

class GLShader : Shader
  PROPERTIES
    GLSL_VERSION     = ""
    HIGH_PRECISION   = ""
    MEDIUM_PRECISION = ""
    LOWP             = ""

    # OpenGL IDs
    vertex_shader_id          : Int32
    pixel_shader_id           : Int32
    program_id                : Int32

    fixed_color_parameter     : Int32
    transform_parameter       : Int32
    texture_parameters        = Int32[]

    position_attribute        : Int32
    color_attribute           : Int32
    normal_attribute          : Int32
    uv_attribute              : Int32
    world_transform_parameter : Int32

  METHODS
    method init( vertex_shader:String, fragment_shader:String )
      if $target("iOS") or $target("Android") or $target("Web")
        # An empty last line is required on HIGH_PRECISION and MEDIUM_PRECISION.
        # Allows high precision if the device supports it
        HIGH_PRECISION =
        @|#ifdef GL_FRAGMENT_PRECISION_HIGH
         |precision highp float;
         |precision highp int;
         |#else
         |precision mediump float;
         |precision mediump int;
         |#endif
         |

        # Definitely use medium precision
        MEDIUM_PRECISION =
        @|precision mediump float;
         |precision mediump int;
         |

        LOWP = " lowp "

      else
        GLSL_VERSION = "#version 110\n"

      endIf

      if (use_high_precision)
        vertex_shader = GLSL_VERSION + HIGH_PRECISION + vertex_shader.replacing( "$LOWP", LOWP )
        fragment_shader = GLSL_VERSION + HIGH_PRECISION + fragment_shader.replacing( "$LOWP", LOWP )
      else
        vertex_shader = GLSL_VERSION + MEDIUM_PRECISION + vertex_shader.replacing( "$LOWP", LOWP )
        fragment_shader = GLSL_VERSION + MEDIUM_PRECISION + fragment_shader.replacing( "$LOWP", LOWP )
      endIf

      native @|$vertex_shader_id = (RogueInt32) glCreateShader( GL_VERTEX_SHADER );
      compile_shader( vertex_shader_id, vertex_shader )
      native @|$pixel_shader_id = (RogueInt32) glCreateShader( GL_FRAGMENT_SHADER );
      compile_shader( pixel_shader_id, fragment_shader )

      local location = 0
      native @|$program_id = glCreateProgram();
              |glAttachShader( $program_id, $vertex_shader_id );
              |glAttachShader( $program_id, $pixel_shader_id );
              |
              |glLinkProgram( $program_id );
              |
              |$fixed_color_parameter = glGetUniformLocation( $program_id, "fixed_color" );
              |
              |$position_attribute = glGetAttribLocation( $program_id, "position" );
              |$color_attribute    = glGetAttribLocation( $program_id, "color" );
              |$normal_attribute   = glGetAttribLocation( $program_id, "normal" );
              |$uv_attribute       = glGetAttribLocation( $program_id,  "uv" );
              |$world_transform_parameter = glGetUniformLocation( $program_id, "world_transform" );
              |$transform_parameter       = glGetUniformLocation( $program_id, "transform" );
              |
              |int slot = 0;
              |while ($location >= 0)
              |{
              |  char name[80];
              |  sprintf( name, "texture_%d", slot );
              |  $location = glGetUniformLocation( $program_id, name );

              texture_parameters.add( location )

      native @|
              |  ++slot;
              |}

    method activate
      native @|glUseProgram( $this->program_id );

    method use_high_precision->Logical
      return (GLRenderer.max_texture_size >= 2048)

    method compile_shader( shader:Int32, shader_source:String )
      native @|const char* source = (const char*) $shader_source->data->as_utf8;
              |glShaderSource( $shader, 1, &source, 0 );
              |glCompileShader( $shader );
              |
              |GLint success = 0;
              |glGetShaderiv( $shader, GL_COMPILE_STATUS, &success );
              |if ( !success )
              |{
              |  GLint log_size = 0;
              |  glGetShaderiv( $shader, GL_INFO_LOG_LENGTH, &log_size );
              |
              |  char* log = (char*) %NS%ROGUE_MALLOC( log_size );
              |  glGetShaderInfoLog( $shader, log_size, &log_size, log );
              |
              |  %NS%ROGUE_LOG_ERROR( "SHADER ERROR:\n%s\n", log );
              |  %NS%ROGUE_FREE( log );
              |}

endClass


class GLColorShader : GLShader
  METHODS
    method init
      local vertex_shader =
        @|attribute vec4  position;
         |attribute $LOWP vec4 color;
         |varying   $LOWP vec4 vertex_color;
         |void main()
         |{
         |  gl_Position = position;
         |  vertex_color = color / 255.0;
         |}

      local fragment_shader =
        @|varying $LOWP vec4 vertex_color;
         |void main()
         |{
         |  gl_FragColor = vertex_color;
         |}

      prior.init( vertex_shader, fragment_shader )
endClass

class GLTextureShader : GLShader
  METHODS
    method init
      local vertex_shader =
        @|attribute vec4 position;
         |attribute vec2 uv;
         |varying   vec2 vertex_uv;
         |
         |void main()
         |{
         |  gl_Position = position;
         |  vertex_uv = uv;
         |}

      local fragment_shader =
        @|uniform sampler2D texture_0;
         |varying vec2      vertex_uv;
         |
         |void main()
         |{
         |  gl_FragColor = texture2D(texture_0,vertex_uv);
         |}

      prior.init( vertex_shader, fragment_shader )
endClass
