module Warlock

enum PrimitiveType
  UNDEFINED,
  LINES,
  TRIANGLES
endEnum

class Renderer [singleton]
  DEFINITIONS
    VERSION = 1

    TOTAL_COUNT_INDEX = 0
    VCOUNT_INDEX      = 2

  PROPERTIES
    render_data        = DataWriter()
    cmd_data           = DataWriter()

    vertices           = Vertex[]
    primitive_type     : PrimitiveType
    current_material   : Material

    transformed_vertex_count : Int
    total_vertex_count       : Int
    flushing                 = false

    standard_shaders   = [String:Shader]
    standard_materials = [String:Material]

  METHODS
    method init
      .configure_shaders_and_materials

      reset

    method reset
      primitive_type = PrimitiveType.UNDEFINED
      current_material = null
      vertices.clear
      transformed_vertex_count = 0
      total_vertex_count = 0
      render_data.clear
      render_data.write_int32( VERSION )
      render_data.write_int32( 0 )  # total dynamic vertex count

    method add_vertex( position:XY, color:Color )
      vertices.add( Vertex(XYZW(position,0,1),color) )

    method add_vertex( position:XY, color:Color, uv:XY )
      vertices.add( Vertex(XYZW(position,0,1),color,uv) )

    method apply_vertex_transform
      if (transformed_vertex_count == vertices.count) return

      local transform = Display.transform
      forEach (vertex in rewriter=vertices.rewriter(&starting_index=transformed_vertex_count))
        local pos = Display.transform * vertex.position
        vertex.position = pos / pos.w
        rewriter.write( vertex )
      endForEach
      transformed_vertex_count = vertices.count

    method define_material( material:Material )
      .begin_command( RenderCmd.DEFINE_MATERIAL )
      cmd_data.write_int32x( material.id )
      cmd_data.write_int32x( material.topology )
      cmd_data.write_int32x( material.primitive_restart_enabled )
      cmd_data.write_int32x( material.shaders.count )
      cmd_data.write_int32x( (forEach in material.shaders).id )
      cmd_data.write_int32x( material.textures.count )
      forEach (texture at layer in material.textures)
        cmd_data.write_int32x( layer )
        cmd_data.write_int32x( texture.id )
      endForEach
      .end_command

    method define_shader( shader:Shader )
      .begin_command( RenderCmd.DEFINE_SHADER )
      cmd_data.write_int32x( shader.id )
      cmd_data.write_int32x( shader.stage )
      cmd_data.write_string( shader.filename )
      cmd_data.write_string( shader.main_fn_name )
      if (shader.source)
        cmd_data.write_logical( true )
        cmd_data.write_string( shader.source )
      else
        cmd_data.write_logical( false )
        cmd_data.write_bytes( shader.spirv )
      endIf
      .end_command

    method define_texture( texture:Texture )
      .begin_command( RenderCmd.DEFINE_TEXTURE )
      cmd_data.write_int32x( texture.id )
      cmd_data.write_int32x( texture.bitmap.width )
      cmd_data.write_int32x( texture.bitmap.height )
      cmd_data.write_colors( texture.bitmap.pixels )
      .end_command

    method draw( triangle:Triangle, color:Color, current_material=Renderer.standard_materials//color_line_material )
      primitive_type = PrimitiveType.LINES
      add_vertex( triangle.a, color )
      add_vertex( triangle.b, color )
      add_vertex( triangle.b, color )
      add_vertex( triangle.c, color )
      add_vertex( triangle.c, color )
      add_vertex( triangle.a, color )

    method fill( box:Box, color:Color, current_material=Renderer.standard_materials//color_triangle_material )
      local tl = box.position
      local tr = box.top_right
      local br = box.bottom_right
      local bl = box.bottom_left
      fill( Triangle(tl,tr,br), color, current_material )
      fill( Triangle(br,bl,tl), color, current_material )

    method fill( triangle:Triangle, color:Color, current_material=Renderer.standard_materials//color_triangle_material )
      primitive_type = PrimitiveType.TRIANGLES
      add_vertex( triangle.a, color )
      add_vertex( triangle.b, color )
      add_vertex( triangle.c, color )

    method fill( triangle:Triangle, color:Color, current_material, uv:Triangle )
      primitive_type = PrimitiveType.TRIANGLES
      add_vertex( triangle.a, color, uv.a )
      add_vertex( triangle.b, color, uv.b )
      add_vertex( triangle.c, color, uv.c )

    method finalized_render_data->Byte[]
      .begin_command( RenderCmd.END_DRAWING )
      .end_command
      render_data.patch_int32( 4, total_vertex_count )
      return render_data.output_bytes

    method find_texture( name:String )->Texture
      return null

    method flush
      if (vertices.is_empty) return

      if (flushing) return
      flushing = true

      apply_vertex_transform

      which (primitive_type)

        case TRIANGLES
          .begin_command( RenderCmd.DRAW_TRIANGLES )
          cmd_data.write_int32x( current_material.id )
          cmd_data.write_int32x( vertices.count / 3 )
          forEach (v in vertices)
            cmd_data.write_real32( v.position.x )
            cmd_data.write_real32( v.position.y )
            cmd_data.write_real32( v.position.z )
            cmd_data.write_real32( v.position.w )
            cmd_data.write_int32( v.color.argb )
            cmd_data.write_real32( v.uv.x )
            cmd_data.write_real32( v.uv.y )
          endForEach

        case LINES
          .begin_command( RenderCmd.DRAW_LINES )
          cmd_data.write_int32x( current_material.id )
          cmd_data.write_int32x( vertices.count / 2 )
          forEach (v in vertices)
            cmd_data.write_real32( v.position.x )
            cmd_data.write_real32( v.position.y )
            cmd_data.write_real32( v.position.z )
            cmd_data.write_real32( v.position.w )
            cmd_data.write_int32( v.color.argb )
          endForEach

      endWhich

      .end_command

      total_vertex_count += vertices.count
      vertices.clear
      transformed_vertex_count = 0

      flushing = false

    method free_material( material:Material )
      .begin_command( RenderCmd.FREE_MATERIAL )
      cmd_data.write_int32x( material.id )
      .end_command

    method free_shader( shader:Shader )
      .begin_command( RenderCmd.FREE_SHADER )
      cmd_data.write_int32x( shader.id )
      .end_command

    method free_texture( texture:Texture )
      .begin_command( RenderCmd.FREE_TEXTURE )
      cmd_data.write_int32x( texture.id )
      .end_command

    method set_current_material( new_material:Material )
      if (current_material is new_material) return
      flush
      @current_material = new_material
      if (new_material) new_material.prepare

    method set_primitive_type( new_type:PrimitiveType )
      if (new_type == @primitive_type) return
      flush
      @primitive_type = new_type

    method .begin_command( cmd:RenderCmd )
      flush
      cmd_data.write_int32x( cmd )

    method .end_command
      render_data.write_int32x( cmd_data.output_bytes.count )
      render_data.write( cmd_data.output_bytes )
      cmd_data.clear

    method .configure_shaders_and_materials
      standard_shaders//color_vertex_shader = Shader(
        ShaderStage.VERTEX,
        "Color Vertex Shader",
        @|#version 450
         |#extension GL_ARB_separate_shader_objects : enable
         |
         |layout (location = 0) in vec4 position;
         |layout (location = 1) in vec4 color;
         |
         |layout (location = 0) out vec4 frag_color;
         |
         |void main ()
         |{
         |  gl_Position = position;
         |  frag_color = color;
         |}
      )

      standard_shaders//color_fragment_shader = Shader(
        ShaderStage.FRAGMENT,
        "Color Fragment Shader",
        @|#version 450
         |#extension GL_ARB_separate_shader_objects : enable
         |
         |layout (location = 0) in  vec4 color;
         |layout (location = 0) out vec4 output_color;
         |
         |void main () { output_color = color; }
      )

      standard_shaders//texture_vertex_shader = Shader(
        ShaderStage.VERTEX,
        "Texture Vertex Shader",
        @|#version 450
         |#extension GL_ARB_separate_shader_objects : enable
         |
         |//layout (binding = 1) uniform Global {vec4 color;} global;
         |
         |layout (location = 0) in vec4 position;
         |layout (location = 1) in vec4 color;
         |layout (location = 2) in vec2 uv;
         |
         |layout (location = 0) out vec4 frag_color;
         |layout (location = 1) out vec2 frag_uv;
         |
         |void main ()
         |{
         |  gl_Position = position;
         |  frag_color = color;
         |  frag_uv = uv;
         |}
      )

      standard_shaders//texture_fragment_shader = Shader(
        ShaderStage.FRAGMENT,
        "Texture Fragment Shader",
        @|#version 450
         |#extension GL_ARB_separate_shader_objects : enable
         |
         |layout (binding = 0) uniform sampler2D texture_sampler;
         |
         |layout (location = 0) in vec4 color;
         |layout (location = 1) in vec2 uv;
         |
         |layout (location = 0) out vec4 output_color;
         |
         |void main () { output_color = texture( texture_sampler, uv ); }
      )

      standard_materials//color_line_material = Material(
        standard_shaders//color_vertex_shader,
        standard_shaders//color_fragment_shader,
        Topology.LINE_LIST
      )

      standard_materials//color_triangle_material = Material(
        standard_shaders//color_vertex_shader,
        standard_shaders//color_fragment_shader,
        Topology.TRIANGLE_LIST
      )

endClass
